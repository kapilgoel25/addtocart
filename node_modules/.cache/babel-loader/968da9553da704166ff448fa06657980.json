{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\n\nconst mergeEtags = require(\"./cache/mergeEtags\");\n/** @typedef {import(\"./Cache\")} Cache */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {WebpackError=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {Error=} err\n * @param {T=} result\n * @returns {void}\n */\n\n\nclass MultiItemCache {\n  /**\n   * @param {ItemCacheFacade[]} items item caches\n   */\n  constructor(items) {\n    this._items = items;\n    if (items.length === 1) return (\n      /** @type {any} */\n      items[0]\n    );\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    const next = i => {\n      this._items[i].get((err, result) => {\n        if (err) return callback(err);\n        if (result !== undefined) return callback(null, result);\n        if (++i >= this._items.length) return callback();\n        next(i);\n      });\n    };\n\n    next(0);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    const next = i => {\n      return this._items[i].getPromise().then(result => {\n        if (result !== undefined) return result;\n        if (++i < this._items.length) return next(i);\n      });\n    };\n\n    return next(0);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    asyncLib.each(this._items, (item, callback) => item.store(data, callback), callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return Promise.all(this._items.map(item => item.storePromise(data))).then(() => {});\n  }\n\n}\n\nclass ItemCacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache item name\n   * @param {Etag | null} etag the etag\n   */\n  constructor(cache, name, etag) {\n    this._cache = cache;\n    this._name = name;\n    this._etag = etag;\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    this._cache.get(this._name, this._etag, callback);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    return new Promise((resolve, reject) => {\n      this._cache.get(this._name, this._etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    this._cache.store(this._name, this._etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(this._name, this._etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(computer, callback) {\n    this.get((err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(computer) {\n    const cacheEntry = await this.getPromise();\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(result);\n    return result;\n  }\n\n}\n\nclass CacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache name\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  constructor(cache, name, hashFunction) {\n    this._cache = cache;\n    this._name = name;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {string} name the child cache name#\n   * @returns {CacheFacade} child cache\n   */\n\n\n  getChildCache(name) {\n    return new CacheFacade(this._cache, `${this._name}|${name}`, this._hashFunction);\n  }\n  /**\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {ItemCacheFacade} item cache\n   */\n\n\n  getItemCache(identifier, etag) {\n    return new ItemCacheFacade(this._cache, `${this._name}|${identifier}`, etag);\n  }\n  /**\n   * @param {HashableObject} obj an hashable object\n   * @returns {Etag} an etag that is lazy hashed\n   */\n\n\n  getLazyHashedEtag(obj) {\n    return getLazyHashedEtag(obj, this._hashFunction);\n  }\n  /**\n   * @param {Etag} a an etag\n   * @param {Etag} b another etag\n   * @returns {Etag} an etag that represents both\n   */\n\n\n  mergeEtags(a, b) {\n    return mergeEtags(a, b);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(identifier, etag, callback) {\n    this._cache.get(`${this._name}|${identifier}`, etag, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise(identifier, etag) {\n    return new Promise((resolve, reject) => {\n      this._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(identifier, etag, data, callback) {\n    this._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(identifier, etag, data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(identifier, etag, computer, callback) {\n    this.get(identifier, etag, (err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(identifier, etag, result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(identifier, etag, computer) {\n    const cacheEntry = await this.getPromise(identifier, etag);\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(identifier, etag, result);\n    return result;\n  }\n\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/CacheFacade.js"],"names":["asyncLib","require","getLazyHashedEtag","mergeEtags","MultiItemCache","constructor","items","_items","length","get","callback","next","i","err","result","undefined","getPromise","then","store","data","each","item","storePromise","Promise","all","map","ItemCacheFacade","cache","name","etag","_cache","_name","_etag","resolve","reject","provide","computer","cacheEntry","providePromise","CacheFacade","hashFunction","_hashFunction","getChildCache","getItemCache","identifier","obj","a","b","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nconst mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {WebpackError=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {Error=} err\n * @param {T=} result\n * @returns {void}\n */\n\nclass MultiItemCache {\n\t/**\n\t * @param {ItemCacheFacade[]} items item caches\n\t */\n\tconstructor(items) {\n\t\tthis._items = items;\n\t\tif (items.length === 1) return /** @type {any} */ (items[0]);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tconst next = i => {\n\t\t\tthis._items[i].get((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result !== undefined) return callback(null, result);\n\t\t\t\tif (++i >= this._items.length) return callback();\n\t\t\t\tnext(i);\n\t\t\t});\n\t\t};\n\t\tnext(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\tconst next = i => {\n\t\t\treturn this._items[i].getPromise().then(result => {\n\t\t\t\tif (result !== undefined) return result;\n\t\t\t\tif (++i < this._items.length) return next(i);\n\t\t\t});\n\t\t};\n\t\treturn next(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tasyncLib.each(\n\t\t\tthis._items,\n\t\t\t(item, callback) => item.store(data, callback),\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn Promise.all(this._items.map(item => item.storePromise(data))).then(\n\t\t\t() => {}\n\t\t);\n\t}\n}\n\nclass ItemCacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache item name\n\t * @param {Etag | null} etag the etag\n\t */\n\tconstructor(cache, name, etag) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._etag = etag;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tthis._cache.get(this._name, this._etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(this._name, this._etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tthis._cache.store(this._name, this._etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(this._name, this._etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(computer, callback) {\n\t\tthis.get((err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(computer) {\n\t\tconst cacheEntry = await this.getPromise();\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(result);\n\t\treturn result;\n\t}\n}\n\nclass CacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache name\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(cache, name, hashFunction) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {string} name the child cache name#\n\t * @returns {CacheFacade} child cache\n\t */\n\tgetChildCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${name}`,\n\t\t\tthis._hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {ItemCacheFacade} item cache\n\t */\n\tgetItemCache(identifier, etag) {\n\t\treturn new ItemCacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${identifier}`,\n\t\t\tetag\n\t\t);\n\t}\n\n\t/**\n\t * @param {HashableObject} obj an hashable object\n\t * @returns {Etag} an etag that is lazy hashed\n\t */\n\tgetLazyHashedEtag(obj) {\n\t\treturn getLazyHashedEtag(obj, this._hashFunction);\n\t}\n\n\t/**\n\t * @param {Etag} a an etag\n\t * @param {Etag} b another etag\n\t * @returns {Etag} an etag that represents both\n\t */\n\tmergeEtags(a, b) {\n\t\treturn mergeEtags(a, b);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tthis._cache.get(`${this._name}|${identifier}`, etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise(identifier, etag) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(identifier, etag, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(identifier, etag, computer, callback) {\n\t\tthis.get(identifier, etag, (err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(identifier, etag, result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(identifier, etag, computer) {\n\t\tconst cacheEntry = await this.getPromise(identifier, etag);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(identifier, etag, result);\n\t\treturn result;\n\t}\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;\n"]},"metadata":{},"sourceType":"script"}