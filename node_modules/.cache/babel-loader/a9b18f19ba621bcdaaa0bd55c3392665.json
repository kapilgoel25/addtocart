{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  getUsedModuleIds,\n  getFullModuleName\n} = require(\"./IdHelpers\");\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"), () => require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\"), {\n  name: \"Hashed Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\n\nclass HashedModuleIdsPlugin {\n  /**\n   * @param {HashedModuleIdsPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    /** @type {HashedModuleIdsPluginOptions} */\n\n    this.options = {\n      context: null,\n      hashFunction: \"md4\",\n      hashDigest: \"base64\",\n      hashDigestLength: 4,\n      ...options\n    };\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", compilation => {\n      compilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", modules => {\n        const chunkGraph = compilation.chunkGraph;\n        const context = this.options.context ? this.options.context : compiler.context;\n        const usedIds = getUsedModuleIds(compilation);\n        const modulesInNaturalOrder = Array.from(modules).filter(m => {\n          if (!m.needId) return false;\n          if (chunkGraph.getNumberOfModuleChunks(m) === 0) return false;\n          return chunkGraph.getModuleId(module) === null;\n        }).sort(compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph));\n\n        for (const module of modulesInNaturalOrder) {\n          const ident = getFullModuleName(module, context, compiler.root);\n          const hash = createHash(options.hashFunction);\n          hash.update(ident || \"\");\n          const hashId =\n          /** @type {string} */\n          hash.digest(options.hashDigest);\n          let len = options.hashDigestLength;\n\n          while (usedIds.has(hashId.substr(0, len))) len++;\n\n          const moduleId = hashId.substr(0, len);\n          chunkGraph.setModuleId(module, moduleId);\n          usedIds.add(moduleId);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = HashedModuleIdsPlugin;","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/ids/HashedModuleIdsPlugin.js"],"names":["compareModulesByPreOrderIndexOrIdentifier","require","createSchemaValidation","createHash","getUsedModuleIds","getFullModuleName","validate","name","baseDataPath","HashedModuleIdsPlugin","constructor","options","context","hashFunction","hashDigest","hashDigestLength","apply","compiler","hooks","compilation","tap","moduleIds","modules","chunkGraph","usedIds","modulesInNaturalOrder","Array","from","filter","m","needId","getNumberOfModuleChunks","getModuleId","module","sort","moduleGraph","ident","root","hash","update","hashId","digest","len","has","substr","moduleId","setModuleId","add","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst { getUsedModuleIds, getFullModuleName } = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/HashedModuleIdsPlugin\").HashedModuleIdsPluginOptions} HashedModuleIdsPluginOptions */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/HashedModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/HashedModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Hashed Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass HashedModuleIdsPlugin {\n\t/**\n\t * @param {HashedModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {HashedModuleIdsPluginOptions} */\n\t\tthis.options = {\n\t\t\tcontext: null,\n\t\t\thashFunction: \"md4\",\n\t\t\thashDigest: \"base64\",\n\t\t\thashDigestLength: 4,\n\t\t\t...options\n\t\t};\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"HashedModuleIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.moduleIds.tap(\"HashedModuleIdsPlugin\", modules => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst context = this.options.context\n\t\t\t\t\t? this.options.context\n\t\t\t\t\t: compiler.context;\n\n\t\t\t\tconst usedIds = getUsedModuleIds(compilation);\n\t\t\t\tconst modulesInNaturalOrder = Array.from(modules)\n\t\t\t\t\t.filter(m => {\n\t\t\t\t\t\tif (!m.needId) return false;\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(m) === 0) return false;\n\t\t\t\t\t\treturn chunkGraph.getModuleId(module) === null;\n\t\t\t\t\t})\n\t\t\t\t\t.sort(\n\t\t\t\t\t\tcompareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)\n\t\t\t\t\t);\n\t\t\t\tfor (const module of modulesInNaturalOrder) {\n\t\t\t\t\tconst ident = getFullModuleName(module, context, compiler.root);\n\t\t\t\t\tconst hash = createHash(options.hashFunction);\n\t\t\t\t\thash.update(ident || \"\");\n\t\t\t\t\tconst hashId = /** @type {string} */ (\n\t\t\t\t\t\thash.digest(options.hashDigest)\n\t\t\t\t\t);\n\t\t\t\t\tlet len = options.hashDigestLength;\n\t\t\t\t\twhile (usedIds.has(hashId.substr(0, len))) len++;\n\t\t\t\t\tconst moduleId = hashId.substr(0, len);\n\t\t\t\t\tchunkGraph.setModuleId(module, moduleId);\n\t\t\t\t\tusedIds.add(moduleId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = HashedModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}