{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst {\n  assignAscendingModuleIds\n} = require(\"./IdHelpers\");\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"), () => require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\"), {\n  name: \"Occurrence Order Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\n\nclass OccurrenceModuleIdsPlugin {\n  /**\n   * @param {OccurrenceModuleIdsPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const prioritiseInitial = this.options.prioritiseInitial;\n    compiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", modules => {\n        const chunkGraph = compilation.chunkGraph;\n        const modulesInOccurrenceOrder = Array.from(modules).filter(m => m.needId && chunkGraph.getNumberOfModuleChunks(m) > 0 && chunkGraph.getModuleId(m) === null);\n        const occursInInitialChunksMap = new Map();\n        const occursInAllChunksMap = new Map();\n        const initialChunkChunkMap = new Map();\n        const entryCountMap = new Map();\n\n        for (const m of modulesInOccurrenceOrder) {\n          let initial = 0;\n          let entry = 0;\n\n          for (const c of chunkGraph.getModuleChunksIterable(m)) {\n            if (c.canBeInitial()) initial++;\n            if (chunkGraph.isEntryModuleInChunk(m, c)) entry++;\n          }\n\n          initialChunkChunkMap.set(m, initial);\n          entryCountMap.set(m, entry);\n        }\n        /**\n         * @param {Module} module module\n         * @returns {number} count of occurs\n         */\n\n\n        const countOccursInEntry = module => {\n          let sum = 0;\n\n          for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n            if (!originModule) continue;\n            if (!connections.some(c => c.isTargetActive(undefined))) continue;\n            sum += initialChunkChunkMap.get(originModule);\n          }\n\n          return sum;\n        };\n        /**\n         * @param {Module} module module\n         * @returns {number} count of occurs\n         */\n\n\n        const countOccurs = module => {\n          let sum = 0;\n\n          for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n            if (!originModule) continue;\n            const chunkModules = chunkGraph.getNumberOfModuleChunks(originModule);\n\n            for (const c of connections) {\n              if (!c.isTargetActive(undefined)) continue;\n              if (!c.dependency) continue;\n              const factor = c.dependency.getNumberOfIdOccurrences();\n              if (factor === 0) continue;\n              sum += factor * chunkModules;\n            }\n          }\n\n          return sum;\n        };\n\n        if (prioritiseInitial) {\n          for (const m of modulesInOccurrenceOrder) {\n            const result = countOccursInEntry(m) + initialChunkChunkMap.get(m) + entryCountMap.get(m);\n            occursInInitialChunksMap.set(m, result);\n          }\n        }\n\n        for (const m of modules) {\n          const result = countOccurs(m) + chunkGraph.getNumberOfModuleChunks(m) + entryCountMap.get(m);\n          occursInAllChunksMap.set(m, result);\n        }\n\n        const naturalCompare = compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph);\n        modulesInOccurrenceOrder.sort((a, b) => {\n          if (prioritiseInitial) {\n            const aEntryOccurs = occursInInitialChunksMap.get(a);\n            const bEntryOccurs = occursInInitialChunksMap.get(b);\n            if (aEntryOccurs > bEntryOccurs) return -1;\n            if (aEntryOccurs < bEntryOccurs) return 1;\n          }\n\n          const aOccurs = occursInAllChunksMap.get(a);\n          const bOccurs = occursInAllChunksMap.get(b);\n          if (aOccurs > bOccurs) return -1;\n          if (aOccurs < bOccurs) return 1;\n          return naturalCompare(a, b);\n        });\n        assignAscendingModuleIds(modulesInOccurrenceOrder, compilation);\n      });\n    });\n  }\n\n}\n\nmodule.exports = OccurrenceModuleIdsPlugin;","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/ids/OccurrenceModuleIdsPlugin.js"],"names":["compareModulesByPreOrderIndexOrIdentifier","require","createSchemaValidation","assignAscendingModuleIds","validate","name","baseDataPath","OccurrenceModuleIdsPlugin","constructor","options","apply","compiler","prioritiseInitial","hooks","compilation","tap","moduleGraph","moduleIds","modules","chunkGraph","modulesInOccurrenceOrder","Array","from","filter","m","needId","getNumberOfModuleChunks","getModuleId","occursInInitialChunksMap","Map","occursInAllChunksMap","initialChunkChunkMap","entryCountMap","initial","entry","c","getModuleChunksIterable","canBeInitial","isEntryModuleInChunk","set","countOccursInEntry","module","sum","originModule","connections","getIncomingConnectionsByOriginModule","some","isTargetActive","undefined","get","countOccurs","chunkModules","dependency","factor","getNumberOfIdOccurrences","result","naturalCompare","sort","a","b","aEntryOccurs","bEntryOccurs","aOccurs","bOccurs","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AACLA,EAAAA;AADK,IAEFC,OAAO,CAAC,qBAAD,CAFX;;AAGA,MAAMC,sBAAsB,GAAGD,OAAO,CAAC,kCAAD,CAAtC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAA+BF,OAAO,CAAC,aAAD,CAA5C;AAEA;;AACA;;AACA;;AACA;;;AAEA,MAAMG,QAAQ,GAAGF,sBAAsB,CACtCD,OAAO,CAAC,8DAAD,CAD+B,EAEtC,MAAMA,OAAO,CAAC,0DAAD,CAFyB,EAGtC;AACCI,EAAAA,IAAI,EAAE,oCADP;AAECC,EAAAA,YAAY,EAAE;AAFf,CAHsC,CAAvC;;AASA,MAAMC,yBAAN,CAAgC;AAC/B;AACD;AACA;AACCC,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACzBL,IAAAA,QAAQ,CAACK,OAAD,CAAR;AACA,SAAKA,OAAL,GAAeA,OAAf;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAMC,iBAAiB,GAAG,KAAKH,OAAL,CAAaG,iBAAvC;AACAD,IAAAA,QAAQ,CAACE,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,2BAA/B,EAA4DD,WAAW,IAAI;AAC1E,YAAME,WAAW,GAAGF,WAAW,CAACE,WAAhC;AAEAF,MAAAA,WAAW,CAACD,KAAZ,CAAkBI,SAAlB,CAA4BF,GAA5B,CAAgC,2BAAhC,EAA6DG,OAAO,IAAI;AACvE,cAAMC,UAAU,GAAGL,WAAW,CAACK,UAA/B;AAEA,cAAMC,wBAAwB,GAAGC,KAAK,CAACC,IAAN,CAAWJ,OAAX,EAAoBK,MAApB,CAChCC,CAAC,IACAA,CAAC,CAACC,MAAF,IACAN,UAAU,CAACO,uBAAX,CAAmCF,CAAnC,IAAwC,CADxC,IAEAL,UAAU,CAACQ,WAAX,CAAuBH,CAAvB,MAA8B,IAJC,CAAjC;AAOA,cAAMI,wBAAwB,GAAG,IAAIC,GAAJ,EAAjC;AACA,cAAMC,oBAAoB,GAAG,IAAID,GAAJ,EAA7B;AAEA,cAAME,oBAAoB,GAAG,IAAIF,GAAJ,EAA7B;AACA,cAAMG,aAAa,GAAG,IAAIH,GAAJ,EAAtB;;AACA,aAAK,MAAML,CAAX,IAAgBJ,wBAAhB,EAA0C;AACzC,cAAIa,OAAO,GAAG,CAAd;AACA,cAAIC,KAAK,GAAG,CAAZ;;AACA,eAAK,MAAMC,CAAX,IAAgBhB,UAAU,CAACiB,uBAAX,CAAmCZ,CAAnC,CAAhB,EAAuD;AACtD,gBAAIW,CAAC,CAACE,YAAF,EAAJ,EAAsBJ,OAAO;AAC7B,gBAAId,UAAU,CAACmB,oBAAX,CAAgCd,CAAhC,EAAmCW,CAAnC,CAAJ,EAA2CD,KAAK;AAChD;;AACDH,UAAAA,oBAAoB,CAACQ,GAArB,CAAyBf,CAAzB,EAA4BS,OAA5B;AACAD,UAAAA,aAAa,CAACO,GAAd,CAAkBf,CAAlB,EAAqBU,KAArB;AACA;AAED;AACJ;AACA;AACA;;;AACI,cAAMM,kBAAkB,GAAGC,MAAM,IAAI;AACpC,cAAIC,GAAG,GAAG,CAAV;;AACA,eAAK,MAAM,CACVC,YADU,EAEVC,WAFU,CAAX,IAGK5B,WAAW,CAAC6B,oCAAZ,CAAiDJ,MAAjD,CAHL,EAG+D;AAC9D,gBAAI,CAACE,YAAL,EAAmB;AACnB,gBAAI,CAACC,WAAW,CAACE,IAAZ,CAAiBX,CAAC,IAAIA,CAAC,CAACY,cAAF,CAAiBC,SAAjB,CAAtB,CAAL,EAAyD;AACzDN,YAAAA,GAAG,IAAIX,oBAAoB,CAACkB,GAArB,CAAyBN,YAAzB,CAAP;AACA;;AACD,iBAAOD,GAAP;AACA,SAXD;AAaA;AACJ;AACA;AACA;;;AACI,cAAMQ,WAAW,GAAGT,MAAM,IAAI;AAC7B,cAAIC,GAAG,GAAG,CAAV;;AACA,eAAK,MAAM,CACVC,YADU,EAEVC,WAFU,CAAX,IAGK5B,WAAW,CAAC6B,oCAAZ,CAAiDJ,MAAjD,CAHL,EAG+D;AAC9D,gBAAI,CAACE,YAAL,EAAmB;AACnB,kBAAMQ,YAAY,GACjBhC,UAAU,CAACO,uBAAX,CAAmCiB,YAAnC,CADD;;AAEA,iBAAK,MAAMR,CAAX,IAAgBS,WAAhB,EAA6B;AAC5B,kBAAI,CAACT,CAAC,CAACY,cAAF,CAAiBC,SAAjB,CAAL,EAAkC;AAClC,kBAAI,CAACb,CAAC,CAACiB,UAAP,EAAmB;AACnB,oBAAMC,MAAM,GAAGlB,CAAC,CAACiB,UAAF,CAAaE,wBAAb,EAAf;AACA,kBAAID,MAAM,KAAK,CAAf,EAAkB;AAClBX,cAAAA,GAAG,IAAIW,MAAM,GAAGF,YAAhB;AACA;AACD;;AACD,iBAAOT,GAAP;AACA,SAlBD;;AAoBA,YAAI9B,iBAAJ,EAAuB;AACtB,eAAK,MAAMY,CAAX,IAAgBJ,wBAAhB,EAA0C;AACzC,kBAAMmC,MAAM,GACXf,kBAAkB,CAAChB,CAAD,CAAlB,GACAO,oBAAoB,CAACkB,GAArB,CAAyBzB,CAAzB,CADA,GAEAQ,aAAa,CAACiB,GAAd,CAAkBzB,CAAlB,CAHD;AAIAI,YAAAA,wBAAwB,CAACW,GAAzB,CAA6Bf,CAA7B,EAAgC+B,MAAhC;AACA;AACD;;AAED,aAAK,MAAM/B,CAAX,IAAgBN,OAAhB,EAAyB;AACxB,gBAAMqC,MAAM,GACXL,WAAW,CAAC1B,CAAD,CAAX,GACAL,UAAU,CAACO,uBAAX,CAAmCF,CAAnC,CADA,GAEAQ,aAAa,CAACiB,GAAd,CAAkBzB,CAAlB,CAHD;AAIAM,UAAAA,oBAAoB,CAACS,GAArB,CAAyBf,CAAzB,EAA4B+B,MAA5B;AACA;;AAED,cAAMC,cAAc,GAAGxD,yCAAyC,CAC/Dc,WAAW,CAACE,WADmD,CAAhE;AAIAI,QAAAA,wBAAwB,CAACqC,IAAzB,CAA8B,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACvC,cAAI/C,iBAAJ,EAAuB;AACtB,kBAAMgD,YAAY,GAAGhC,wBAAwB,CAACqB,GAAzB,CAA6BS,CAA7B,CAArB;AACA,kBAAMG,YAAY,GAAGjC,wBAAwB,CAACqB,GAAzB,CAA6BU,CAA7B,CAArB;AACA,gBAAIC,YAAY,GAAGC,YAAnB,EAAiC,OAAO,CAAC,CAAR;AACjC,gBAAID,YAAY,GAAGC,YAAnB,EAAiC,OAAO,CAAP;AACjC;;AACD,gBAAMC,OAAO,GAAGhC,oBAAoB,CAACmB,GAArB,CAAyBS,CAAzB,CAAhB;AACA,gBAAMK,OAAO,GAAGjC,oBAAoB,CAACmB,GAArB,CAAyBU,CAAzB,CAAhB;AACA,cAAIG,OAAO,GAAGC,OAAd,EAAuB,OAAO,CAAC,CAAR;AACvB,cAAID,OAAO,GAAGC,OAAd,EAAuB,OAAO,CAAP;AACvB,iBAAOP,cAAc,CAACE,CAAD,EAAIC,CAAJ,CAArB;AACA,SAZD;AAcAxD,QAAAA,wBAAwB,CAACiB,wBAAD,EAA2BN,WAA3B,CAAxB;AACA,OAxGD;AAyGA,KA5GD;AA6GA;;AA7H8B;;AAgIhC2B,MAAM,CAACuB,OAAP,GAAiBzD,yBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst { assignAscendingModuleIds } = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Occurrence Order Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass OccurrenceModuleIdsPlugin {\n\t/**\n\t * @param {OccurrenceModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst prioritiseInitial = this.options.prioritiseInitial;\n\t\tcompiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\t\tcompilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", modules => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\n\t\t\t\tconst modulesInOccurrenceOrder = Array.from(modules).filter(\n\t\t\t\t\tm =>\n\t\t\t\t\t\tm.needId &&\n\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(m) > 0 &&\n\t\t\t\t\t\tchunkGraph.getModuleId(m) === null\n\t\t\t\t);\n\n\t\t\t\tconst occursInInitialChunksMap = new Map();\n\t\t\t\tconst occursInAllChunksMap = new Map();\n\n\t\t\t\tconst initialChunkChunkMap = new Map();\n\t\t\t\tconst entryCountMap = new Map();\n\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\tlet initial = 0;\n\t\t\t\t\tlet entry = 0;\n\t\t\t\t\tfor (const c of chunkGraph.getModuleChunksIterable(m)) {\n\t\t\t\t\t\tif (c.canBeInitial()) initial++;\n\t\t\t\t\t\tif (chunkGraph.isEntryModuleInChunk(m, c)) entry++;\n\t\t\t\t\t}\n\t\t\t\t\tinitialChunkChunkMap.set(m, initial);\n\t\t\t\t\tentryCountMap.set(m, entry);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccursInEntry = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tif (!connections.some(c => c.isTargetActive(undefined))) continue;\n\t\t\t\t\t\tsum += initialChunkChunkMap.get(originModule);\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccurs = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tconst chunkModules =\n\t\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(originModule);\n\t\t\t\t\t\tfor (const c of connections) {\n\t\t\t\t\t\t\tif (!c.isTargetActive(undefined)) continue;\n\t\t\t\t\t\t\tif (!c.dependency) continue;\n\t\t\t\t\t\t\tconst factor = c.dependency.getNumberOfIdOccurrences();\n\t\t\t\t\t\t\tif (factor === 0) continue;\n\t\t\t\t\t\t\tsum += factor * chunkModules;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\tcountOccursInEntry(m) +\n\t\t\t\t\t\t\tinitialChunkChunkMap.get(m) +\n\t\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\t\toccursInInitialChunksMap.set(m, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\tconst result =\n\t\t\t\t\t\tcountOccurs(m) +\n\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(m) +\n\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\toccursInAllChunksMap.set(m, result);\n\t\t\t\t}\n\n\t\t\t\tconst naturalCompare = compareModulesByPreOrderIndexOrIdentifier(\n\t\t\t\t\tcompilation.moduleGraph\n\t\t\t\t);\n\n\t\t\t\tmodulesInOccurrenceOrder.sort((a, b) => {\n\t\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\t\tconst aEntryOccurs = occursInInitialChunksMap.get(a);\n\t\t\t\t\t\tconst bEntryOccurs = occursInInitialChunksMap.get(b);\n\t\t\t\t\t\tif (aEntryOccurs > bEntryOccurs) return -1;\n\t\t\t\t\t\tif (aEntryOccurs < bEntryOccurs) return 1;\n\t\t\t\t\t}\n\t\t\t\t\tconst aOccurs = occursInAllChunksMap.get(a);\n\t\t\t\t\tconst bOccurs = occursInAllChunksMap.get(b);\n\t\t\t\t\tif (aOccurs > bOccurs) return -1;\n\t\t\t\t\tif (aOccurs < bOccurs) return 1;\n\t\t\t\t\treturn naturalCompare(a, b);\n\t\t\t\t});\n\n\t\t\t\tassignAscendingModuleIds(modulesInOccurrenceOrder, compilation);\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = OccurrenceModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}