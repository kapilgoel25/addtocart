{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst {\n  getShortModuleName,\n  getLongModuleName,\n  assignNames,\n  getUsedModuleIds,\n  assignAscendingModuleIds\n} = require(\"./IdHelpers\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nclass NamedModuleIdsPlugin {\n  constructor(options) {\n    this.options = options || {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      root\n    } = compiler;\n    compiler.hooks.compilation.tap(\"NamedModuleIdsPlugin\", compilation => {\n      const {\n        hashFunction\n      } = compilation.outputOptions;\n      compilation.hooks.moduleIds.tap(\"NamedModuleIdsPlugin\", modules => {\n        const chunkGraph = compilation.chunkGraph;\n        const context = this.options.context ? this.options.context : compiler.context;\n        const unnamedModules = assignNames(Array.from(modules).filter(module => {\n          if (!module.needId) return false;\n          if (chunkGraph.getNumberOfModuleChunks(module) === 0) return false;\n          return chunkGraph.getModuleId(module) === null;\n        }), m => getShortModuleName(m, context, root), (m, shortName) => getLongModuleName(shortName, m, context, hashFunction, root), compareModulesByIdentifier, getUsedModuleIds(compilation), (m, name) => chunkGraph.setModuleId(m, name));\n\n        if (unnamedModules.length > 0) {\n          assignAscendingModuleIds(unnamedModules, compilation);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = NamedModuleIdsPlugin;","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/ids/NamedModuleIdsPlugin.js"],"names":["compareModulesByIdentifier","require","getShortModuleName","getLongModuleName","assignNames","getUsedModuleIds","assignAscendingModuleIds","NamedModuleIdsPlugin","constructor","options","apply","compiler","root","hooks","compilation","tap","hashFunction","outputOptions","moduleIds","modules","chunkGraph","context","unnamedModules","Array","from","filter","module","needId","getNumberOfModuleChunks","getModuleId","m","shortName","name","setModuleId","length","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAiCC,OAAO,CAAC,qBAAD,CAA9C;;AACA,MAAM;AACLC,EAAAA,kBADK;AAELC,EAAAA,iBAFK;AAGLC,EAAAA,WAHK;AAILC,EAAAA,gBAJK;AAKLC,EAAAA;AALK,IAMFL,OAAO,CAAC,aAAD,CANX;AAQA;;AACA;;;AAEA,MAAMM,oBAAN,CAA2B;AAC1BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACpB,SAAKA,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACf,UAAM;AAAEC,MAAAA;AAAF,QAAWD,QAAjB;AACAA,IAAAA,QAAQ,CAACE,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,sBAA/B,EAAuDD,WAAW,IAAI;AACrE,YAAM;AAAEE,QAAAA;AAAF,UAAmBF,WAAW,CAACG,aAArC;AACAH,MAAAA,WAAW,CAACD,KAAZ,CAAkBK,SAAlB,CAA4BH,GAA5B,CAAgC,sBAAhC,EAAwDI,OAAO,IAAI;AAClE,cAAMC,UAAU,GAAGN,WAAW,CAACM,UAA/B;AACA,cAAMC,OAAO,GAAG,KAAKZ,OAAL,CAAaY,OAAb,GACb,KAAKZ,OAAL,CAAaY,OADA,GAEbV,QAAQ,CAACU,OAFZ;AAIA,cAAMC,cAAc,GAAGlB,WAAW,CACjCmB,KAAK,CAACC,IAAN,CAAWL,OAAX,EAAoBM,MAApB,CAA2BC,MAAM,IAAI;AACpC,cAAI,CAACA,MAAM,CAACC,MAAZ,EAAoB,OAAO,KAAP;AACpB,cAAIP,UAAU,CAACQ,uBAAX,CAAmCF,MAAnC,MAA+C,CAAnD,EAAsD,OAAO,KAAP;AACtD,iBAAON,UAAU,CAACS,WAAX,CAAuBH,MAAvB,MAAmC,IAA1C;AACA,SAJD,CADiC,EAMjCI,CAAC,IAAI5B,kBAAkB,CAAC4B,CAAD,EAAIT,OAAJ,EAAaT,IAAb,CANU,EAOjC,CAACkB,CAAD,EAAIC,SAAJ,KACC5B,iBAAiB,CAAC4B,SAAD,EAAYD,CAAZ,EAAeT,OAAf,EAAwBL,YAAxB,EAAsCJ,IAAtC,CARe,EASjCZ,0BATiC,EAUjCK,gBAAgB,CAACS,WAAD,CAViB,EAWjC,CAACgB,CAAD,EAAIE,IAAJ,KAAaZ,UAAU,CAACa,WAAX,CAAuBH,CAAvB,EAA0BE,IAA1B,CAXoB,CAAlC;;AAaA,YAAIV,cAAc,CAACY,MAAf,GAAwB,CAA5B,EAA+B;AAC9B5B,UAAAA,wBAAwB,CAACgB,cAAD,EAAiBR,WAAjB,CAAxB;AACA;AACD,OAtBD;AAuBA,KAzBD;AA0BA;;AAtCyB;;AAyC3BY,MAAM,CAACS,OAAP,GAAiB5B,oBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tgetShortModuleName,\n\tgetLongModuleName,\n\tassignNames,\n\tgetUsedModuleIds,\n\tassignAscendingModuleIds\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass NamedModuleIdsPlugin {\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { root } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"NamedModuleIdsPlugin\", compilation => {\n\t\t\tconst { hashFunction } = compilation.outputOptions;\n\t\t\tcompilation.hooks.moduleIds.tap(\"NamedModuleIdsPlugin\", modules => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst context = this.options.context\n\t\t\t\t\t? this.options.context\n\t\t\t\t\t: compiler.context;\n\n\t\t\t\tconst unnamedModules = assignNames(\n\t\t\t\t\tArray.from(modules).filter(module => {\n\t\t\t\t\t\tif (!module.needId) return false;\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) return false;\n\t\t\t\t\t\treturn chunkGraph.getModuleId(module) === null;\n\t\t\t\t\t}),\n\t\t\t\t\tm => getShortModuleName(m, context, root),\n\t\t\t\t\t(m, shortName) =>\n\t\t\t\t\t\tgetLongModuleName(shortName, m, context, hashFunction, root),\n\t\t\t\t\tcompareModulesByIdentifier,\n\t\t\t\t\tgetUsedModuleIds(compilation),\n\t\t\t\t\t(m, name) => chunkGraph.setModuleId(m, name)\n\t\t\t\t);\n\t\t\t\tif (unnamedModules.length > 0) {\n\t\t\t\t\tassignAscendingModuleIds(unnamedModules, compilation);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = NamedModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}