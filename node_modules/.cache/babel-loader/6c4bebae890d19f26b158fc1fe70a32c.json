{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\n\nclass CacheEntry {\n  constructor(result, snapshot) {\n    this.result = result;\n    this.snapshot = snapshot;\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.result);\n    write(this.snapshot);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.result = read();\n    this.snapshot = read();\n  }\n\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\n\nconst addAllToSet = (set, otherSet) => {\n  if (set instanceof LazySet) {\n    set.addAll(otherSet);\n  } else {\n    for (const item of otherSet) {\n      set.add(item);\n    }\n  }\n};\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\n\n\nconst objectToString = (object, excludeContext) => {\n  let str = \"\";\n\n  for (const key in object) {\n    if (excludeContext && key === \"context\") continue;\n    const value = object[key];\n\n    if (typeof value === \"object\" && value !== null) {\n      str += `|${key}=[${objectToString(value, false)}|]`;\n    } else {\n      str += `|${key}=|${value}`;\n    }\n  }\n\n  return str;\n};\n\nclass ResolverCachePlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cache = compiler.getCache(\"ResolverCachePlugin\");\n    /** @type {FileSystemInfo} */\n\n    let fileSystemInfo;\n    let snapshotOptions;\n    let realResolves = 0;\n    let cachedResolves = 0;\n    let cacheInvalidResolves = 0;\n    let concurrentResolves = 0;\n    compiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n      snapshotOptions = compilation.options.snapshot.resolve;\n      fileSystemInfo = compilation.fileSystemInfo;\n      compilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n        if (realResolves + cachedResolves > 0) {\n          const logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n          logger.log(`${Math.round(100 * realResolves / (realResolves + cachedResolves))}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`);\n          realResolves = 0;\n          cachedResolves = 0;\n          cacheInvalidResolves = 0;\n          concurrentResolves = 0;\n        }\n      });\n    });\n    /**\n     * @param {ItemCacheFacade} itemCache cache\n     * @param {Resolver} resolver the resolver\n     * @param {Object} resolveContext context for resolving meta info\n     * @param {Object} request the request info object\n     * @param {function(Error=, Object=): void} callback callback function\n     * @returns {void}\n     */\n\n    const doRealResolve = (itemCache, resolver, resolveContext, request, callback) => {\n      realResolves++;\n      const newRequest = {\n        _ResolverCachePluginCacheMiss: true,\n        ...request\n      };\n      const newResolveContext = { ...resolveContext,\n        stack: new Set(),\n        missingDependencies: new LazySet(),\n        fileDependencies: new LazySet(),\n        contextDependencies: new LazySet()\n      };\n\n      const propagate = key => {\n        if (resolveContext[key]) {\n          addAllToSet(resolveContext[key], newResolveContext[key]);\n        }\n      };\n\n      const resolveTime = Date.now();\n      resolver.doResolve(resolver.hooks.resolve, newRequest, \"Cache miss\", newResolveContext, (err, result) => {\n        propagate(\"fileDependencies\");\n        propagate(\"contextDependencies\");\n        propagate(\"missingDependencies\");\n        if (err) return callback(err);\n        const fileDependencies = newResolveContext.fileDependencies;\n        const contextDependencies = newResolveContext.contextDependencies;\n        const missingDependencies = newResolveContext.missingDependencies;\n        fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, (err, snapshot) => {\n          if (err) return callback(err);\n\n          if (!snapshot) {\n            if (result) return callback(null, result);\n            return callback();\n          }\n\n          itemCache.store(new CacheEntry(result, snapshot), storeErr => {\n            if (storeErr) return callback(storeErr);\n            if (result) return callback(null, result);\n            callback();\n          });\n        });\n      });\n    };\n\n    compiler.resolverFactory.hooks.resolver.intercept({\n      factory(type, hook) {\n        /** @type {Map<string, (function(Error=, Object=): void)[]>} */\n        const activeRequests = new Map();\n        hook.tap(\"ResolverCachePlugin\",\n        /**\n         * @param {Resolver} resolver the resolver\n         * @param {Object} options resolve options\n         * @param {Object} userOptions resolve options passed by the user\n         * @returns {void}\n         */\n        (resolver, options, userOptions) => {\n          if (options.cache !== true) return;\n          const optionsIdent = objectToString(userOptions, false);\n          const cacheWithContext = options.cacheWithContext !== undefined ? options.cacheWithContext : false;\n          resolver.hooks.resolve.tapAsync({\n            name: \"ResolverCachePlugin\",\n            stage: -100\n          }, (request, resolveContext, callback) => {\n            if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n              return callback();\n            }\n\n            const identifier = `${type}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n            const activeRequest = activeRequests.get(identifier);\n\n            if (activeRequest) {\n              activeRequest.push(callback);\n              return;\n            }\n\n            const itemCache = cache.getItemCache(identifier, null);\n            let callbacks;\n\n            const done = (err, result) => {\n              if (callbacks === undefined) {\n                callback(err, result);\n                callbacks = false;\n              } else {\n                for (const callback of callbacks) {\n                  callback(err, result);\n                }\n\n                activeRequests.delete(identifier);\n                callbacks = false;\n              }\n            };\n            /**\n             * @param {Error=} err error if any\n             * @param {CacheEntry=} cacheEntry cache entry\n             * @returns {void}\n             */\n\n\n            const processCacheResult = (err, cacheEntry) => {\n              if (err) return done(err);\n\n              if (cacheEntry) {\n                const {\n                  snapshot,\n                  result\n                } = cacheEntry;\n                fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) => {\n                  if (err || !valid) {\n                    cacheInvalidResolves++;\n                    return doRealResolve(itemCache, resolver, resolveContext, request, done);\n                  }\n\n                  cachedResolves++;\n\n                  if (resolveContext.missingDependencies) {\n                    addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable());\n                  }\n\n                  if (resolveContext.fileDependencies) {\n                    addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable());\n                  }\n\n                  if (resolveContext.contextDependencies) {\n                    addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable());\n                  }\n\n                  done(null, result);\n                });\n              } else {\n                doRealResolve(itemCache, resolver, resolveContext, request, done);\n              }\n            };\n\n            itemCache.get(processCacheResult);\n\n            if (callbacks === undefined) {\n              callbacks = [callback];\n              activeRequests.set(identifier, callbacks);\n            }\n          });\n        });\n        return hook;\n      }\n\n    });\n  }\n\n}\n\nmodule.exports = ResolverCachePlugin;","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/cache/ResolverCachePlugin.js"],"names":["LazySet","require","makeSerializable","CacheEntry","constructor","result","snapshot","serialize","write","deserialize","read","addAllToSet","set","otherSet","addAll","item","add","objectToString","object","excludeContext","str","key","value","ResolverCachePlugin","apply","compiler","cache","getCache","fileSystemInfo","snapshotOptions","realResolves","cachedResolves","cacheInvalidResolves","concurrentResolves","hooks","thisCompilation","tap","compilation","options","resolve","finishModules","logger","getLogger","log","Math","round","doRealResolve","itemCache","resolver","resolveContext","request","callback","newRequest","_ResolverCachePluginCacheMiss","newResolveContext","stack","Set","missingDependencies","fileDependencies","contextDependencies","propagate","resolveTime","Date","now","doResolve","err","createSnapshot","store","storeErr","resolverFactory","intercept","factory","type","hook","activeRequests","Map","userOptions","optionsIdent","cacheWithContext","undefined","tapAsync","name","stage","identifier","activeRequest","get","push","getItemCache","callbacks","done","delete","processCacheResult","cacheEntry","checkSnapshotValid","valid","getMissingIterable","getFileIterable","getContextIterable","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n\tconstructor(result, snapshot) {\n\t\tthis.result = result;\n\t\tthis.snapshot = snapshot;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.result);\n\t\twrite(this.snapshot);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.result = read();\n\t\tthis.snapshot = read();\n\t}\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tif (set instanceof LazySet) {\n\t\tset.addAll(otherSet);\n\t} else {\n\t\tfor (const item of otherSet) {\n\t\t\tset.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n\tlet str = \"\";\n\tfor (const key in object) {\n\t\tif (excludeContext && key === \"context\") continue;\n\t\tconst value = object[key];\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tstr += `|${key}=[${objectToString(value, false)}|]`;\n\t\t} else {\n\t\t\tstr += `|${key}=|${value}`;\n\t\t}\n\t}\n\treturn str;\n};\n\nclass ResolverCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cache = compiler.getCache(\"ResolverCachePlugin\");\n\t\t/** @type {FileSystemInfo} */\n\t\tlet fileSystemInfo;\n\t\tlet snapshotOptions;\n\t\tlet realResolves = 0;\n\t\tlet cachedResolves = 0;\n\t\tlet cacheInvalidResolves = 0;\n\t\tlet concurrentResolves = 0;\n\t\tcompiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n\t\t\tsnapshotOptions = compilation.options.snapshot.resolve;\n\t\t\tfileSystemInfo = compilation.fileSystemInfo;\n\t\t\tcompilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n\t\t\t\tif (realResolves + cachedResolves > 0) {\n\t\t\t\t\tconst logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t(100 * realResolves) / (realResolves + cachedResolves)\n\t\t\t\t\t\t)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`\n\t\t\t\t\t);\n\t\t\t\t\trealResolves = 0;\n\t\t\t\t\tcachedResolves = 0;\n\t\t\t\t\tcacheInvalidResolves = 0;\n\t\t\t\t\tconcurrentResolves = 0;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t * @param {ItemCacheFacade} itemCache cache\n\t\t * @param {Resolver} resolver the resolver\n\t\t * @param {Object} resolveContext context for resolving meta info\n\t\t * @param {Object} request the request info object\n\t\t * @param {function(Error=, Object=): void} callback callback function\n\t\t * @returns {void}\n\t\t */\n\t\tconst doRealResolve = (\n\t\t\titemCache,\n\t\t\tresolver,\n\t\t\tresolveContext,\n\t\t\trequest,\n\t\t\tcallback\n\t\t) => {\n\t\t\trealResolves++;\n\t\t\tconst newRequest = {\n\t\t\t\t_ResolverCachePluginCacheMiss: true,\n\t\t\t\t...request\n\t\t\t};\n\t\t\tconst newResolveContext = {\n\t\t\t\t...resolveContext,\n\t\t\t\tstack: new Set(),\n\t\t\t\tmissingDependencies: new LazySet(),\n\t\t\t\tfileDependencies: new LazySet(),\n\t\t\t\tcontextDependencies: new LazySet()\n\t\t\t};\n\t\t\tconst propagate = key => {\n\t\t\t\tif (resolveContext[key]) {\n\t\t\t\t\taddAllToSet(resolveContext[key], newResolveContext[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst resolveTime = Date.now();\n\t\t\tresolver.doResolve(\n\t\t\t\tresolver.hooks.resolve,\n\t\t\t\tnewRequest,\n\t\t\t\t\"Cache miss\",\n\t\t\t\tnewResolveContext,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tpropagate(\"fileDependencies\");\n\t\t\t\t\tpropagate(\"contextDependencies\");\n\t\t\t\t\tpropagate(\"missingDependencies\");\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst fileDependencies = newResolveContext.fileDependencies;\n\t\t\t\t\tconst contextDependencies = newResolveContext.contextDependencies;\n\t\t\t\t\tconst missingDependencies = newResolveContext.missingDependencies;\n\t\t\t\t\tfileSystemInfo.createSnapshot(\n\t\t\t\t\t\tresolveTime,\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tsnapshotOptions,\n\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemCache.store(new CacheEntry(result, snapshot), storeErr => {\n\t\t\t\t\t\t\t\tif (storeErr) return callback(storeErr);\n\t\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\tcompiler.resolverFactory.hooks.resolver.intercept({\n\t\t\tfactory(type, hook) {\n\t\t\t\t/** @type {Map<string, (function(Error=, Object=): void)[]>} */\n\t\t\t\tconst activeRequests = new Map();\n\t\t\t\thook.tap(\n\t\t\t\t\t\"ResolverCachePlugin\",\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Resolver} resolver the resolver\n\t\t\t\t\t * @param {Object} options resolve options\n\t\t\t\t\t * @param {Object} userOptions resolve options passed by the user\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(resolver, options, userOptions) => {\n\t\t\t\t\t\tif (options.cache !== true) return;\n\t\t\t\t\t\tconst optionsIdent = objectToString(userOptions, false);\n\t\t\t\t\t\tconst cacheWithContext =\n\t\t\t\t\t\t\toptions.cacheWithContext !== undefined\n\t\t\t\t\t\t\t\t? options.cacheWithContext\n\t\t\t\t\t\t\t\t: false;\n\t\t\t\t\t\tresolver.hooks.resolve.tapAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ResolverCachePlugin\",\n\t\t\t\t\t\t\t\tstage: -100\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\t\t\t\tif (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst identifier = `${type}${optionsIdent}${objectToString(\n\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t!cacheWithContext\n\t\t\t\t\t\t\t\t)}`;\n\t\t\t\t\t\t\t\tconst activeRequest = activeRequests.get(identifier);\n\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\tactiveRequest.push(callback);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst itemCache = cache.getItemCache(identifier, null);\n\t\t\t\t\t\t\t\tlet callbacks;\n\t\t\t\t\t\t\t\tconst done = (err, result) => {\n\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tactiveRequests.delete(identifier);\n\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Error=} err error if any\n\t\t\t\t\t\t\t\t * @param {CacheEntry=} cacheEntry cache entry\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processCacheResult = (err, cacheEntry) => {\n\t\t\t\t\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\t\tconst { snapshot, result } = cacheEntry;\n\t\t\t\t\t\t\t\t\t\tfileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err || !valid) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheInvalidResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn doRealResolve(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcachedResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getMissingIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.fileDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getFileIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.contextDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getContextIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdone(null, result);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdoRealResolve(\n\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\titemCache.get(processCacheResult);\n\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tactiveRequests.set(identifier, callbacks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\treturn hook;\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = ResolverCachePlugin;\n"]},"metadata":{},"sourceType":"script"}