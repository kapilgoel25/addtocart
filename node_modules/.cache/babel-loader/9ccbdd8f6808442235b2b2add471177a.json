{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n  if (relativePath === \"\") return \"./.\";\n  if (relativePath === \"..\") return \"../.\";\n  if (relativePath.startsWith(\"../\")) return relativePath;\n  return `./${relativePath}`;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\n\n\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n  if (maybeAbsolutePath[0] === \"/\") {\n    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\") {\n      // this 'path' is actually a regexp generated by dynamic requires.\n      // Don't treat it as an absolute path.\n      return maybeAbsolutePath;\n    }\n\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = relativePathToRequest(path.posix.relative(context, resource));\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n\n  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = path.win32.relative(context, resource);\n\n    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n      resource = relativePathToRequest(resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\"));\n    }\n\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  } // not an absolute path\n\n\n  return maybeAbsolutePath;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\n\n\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n\nconst makeCacheable = fn => {\n  /** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n  const cache = new WeakMap();\n  /**\n   * @param {string} context context used to create relative path\n   * @param {string} identifier identifier used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {string} the returned relative path\n   */\n\n  const cachedFn = (context, identifier, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return fn(context, identifier);\n    let innerCache = cache.get(associatedObjectForCache);\n\n    if (innerCache === undefined) {\n      innerCache = new Map();\n      cache.set(associatedObjectForCache, innerCache);\n    }\n\n    let cachedResult;\n    let innerSubCache = innerCache.get(context);\n\n    if (innerSubCache === undefined) {\n      innerCache.set(context, innerSubCache = new Map());\n    } else {\n      cachedResult = innerSubCache.get(identifier);\n    }\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    } else {\n      const result = fn(context, identifier);\n      innerSubCache.set(identifier, result);\n      return result;\n    }\n  };\n  /**\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string, string): string} cached function\n   */\n\n\n  cachedFn.bindCache = associatedObjectForCache => {\n    let innerCache;\n\n    if (associatedObjectForCache) {\n      innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n    } else {\n      innerCache = new Map();\n    }\n    /**\n     * @param {string} context context used to create relative path\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = (context, identifier) => {\n      let cachedResult;\n      let innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      } else {\n        cachedResult = innerSubCache.get(identifier);\n      }\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n  /**\n   * @param {string} context context used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string): string} cached function\n   */\n\n\n  cachedFn.bindContextCache = (context, associatedObjectForCache) => {\n    let innerSubCache;\n\n    if (associatedObjectForCache) {\n      let innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n\n      innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      }\n    } else {\n      innerSubCache = new Map();\n    }\n    /**\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = identifier => {\n      const cachedResult = innerSubCache.get(identifier);\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n\n  return cachedFn;\n};\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => absoluteToRequest(context, str)).join(\"\");\n};\n\nexports.makePathsRelative = makeCacheable(_makePathsRelative);\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\nconst _makePathsAbsolute = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => requestToAbsolute(context, str)).join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheable(_makePathsAbsolute);\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\nconst _contextify = (context, request) => {\n  return request.split(\"!\").map(r => absoluteToRequest(context, r)).join(\"!\");\n};\n\nconst contextify = makeCacheable(_contextify);\nexports.contextify = contextify;\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\n\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\n\nconst absolutify = makeCacheable(_absolutify);\nexports.absolutify = absolutify;\nconst PATH_QUERY_FRAGMENT_REGEXP = /^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\n\nconst _parseResource = str => {\n  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n    fragment: match[3] || \"\"\n  };\n};\n\nexports.parseResource = (realFn => {\n  /** @type {WeakMap<object, Map<string, ParsedResource>>} */\n  const cache = new WeakMap();\n\n  const getCache = associatedObjectForCache => {\n    const entry = cache.get(associatedObjectForCache);\n    if (entry !== undefined) return entry;\n    /** @type {Map<string, ParsedResource>} */\n\n    const map = new Map();\n    cache.set(associatedObjectForCache, map);\n    return map;\n  };\n  /**\n   * @param {string} str the path with query and fragment\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {ParsedResource} parsed parts\n   */\n\n\n  const fn = (str, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return realFn(str);\n    const cache = getCache(associatedObjectForCache);\n    const entry = cache.get(str);\n    if (entry !== undefined) return entry;\n    const result = realFn(str);\n    cache.set(str, result);\n    return result;\n  };\n\n  fn.bindCache = associatedObjectForCache => {\n    const cache = getCache(associatedObjectForCache);\n    return str => {\n      const entry = cache.get(str);\n      if (entry !== undefined) return entry;\n      const result = realFn(str);\n      cache.set(str, result);\n      return result;\n    };\n  };\n\n  return fn;\n})(_parseResource);\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\n\n\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n  let depth = -1;\n  let append = \"\";\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) return outputPath + \"/\";\n        append = outputPath.slice(pos + 1) + \"/\" + append;\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      depth++;\n    }\n  }\n\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n};","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/util/identifier.js"],"names":["path","require","WINDOWS_ABS_PATH_REGEXP","SEGMENTS_SPLIT_REGEXP","WINDOWS_PATH_SEPARATOR_REGEXP","relativePathToRequest","relativePath","startsWith","absoluteToRequest","context","maybeAbsolutePath","length","querySplitPos","indexOf","resource","slice","posix","relative","test","win32","replace","requestToAbsolute","join","makeCacheable","fn","cache","WeakMap","cachedFn","identifier","associatedObjectForCache","innerCache","get","undefined","Map","set","cachedResult","innerSubCache","result","bindCache","boundFn","bindContextCache","_makePathsRelative","split","map","str","exports","makePathsRelative","_makePathsAbsolute","makePathsAbsolute","_contextify","request","r","contextify","_absolutify","absolutify","PATH_QUERY_FRAGMENT_REGEXP","_parseResource","match","exec","query","fragment","parseResource","realFn","getCache","entry","getUndoPath","filename","outputPath","enforceRelative","depth","append","part","i","lastIndexOf","j","pos","Math","max","repeat"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMC,uBAAuB,GAAG,iBAAhC;AACA,MAAMC,qBAAqB,GAAG,QAA9B;AACA,MAAMC,6BAA6B,GAAG,KAAtC;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,qBAAqB,GAAGC,YAAY,IAAI;AAC7C,MAAIA,YAAY,KAAK,EAArB,EAAyB,OAAO,KAAP;AACzB,MAAIA,YAAY,KAAK,IAArB,EAA2B,OAAO,MAAP;AAC3B,MAAIA,YAAY,CAACC,UAAb,CAAwB,KAAxB,CAAJ,EAAoC,OAAOD,YAAP;AACpC,SAAQ,KAAIA,YAAa,EAAzB;AACA,CALD;AAOA;AACA;AACA;AACA;AACA;;;AACA,MAAME,iBAAiB,GAAG,CAACC,OAAD,EAAUC,iBAAV,KAAgC;AACzD,MAAIA,iBAAiB,CAAC,CAAD,CAAjB,KAAyB,GAA7B,EAAkC;AACjC,QACCA,iBAAiB,CAACC,MAAlB,GAA2B,CAA3B,IACAD,iBAAiB,CAACA,iBAAiB,CAACC,MAAlB,GAA2B,CAA5B,CAAjB,KAAoD,GAFrD,EAGE;AACD;AACA;AACA,aAAOD,iBAAP;AACA;;AAED,UAAME,aAAa,GAAGF,iBAAiB,CAACG,OAAlB,CAA0B,GAA1B,CAAtB;AACA,QAAIC,QAAQ,GACXF,aAAa,KAAK,CAAC,CAAnB,GACGF,iBADH,GAEGA,iBAAiB,CAACK,KAAlB,CAAwB,CAAxB,EAA2BH,aAA3B,CAHJ;AAIAE,IAAAA,QAAQ,GAAGT,qBAAqB,CAACL,IAAI,CAACgB,KAAL,CAAWC,QAAX,CAAoBR,OAApB,EAA6BK,QAA7B,CAAD,CAAhC;AACA,WAAOF,aAAa,KAAK,CAAC,CAAnB,GACJE,QADI,GAEJA,QAAQ,GAAGJ,iBAAiB,CAACK,KAAlB,CAAwBH,aAAxB,CAFd;AAGA;;AAED,MAAIV,uBAAuB,CAACgB,IAAxB,CAA6BR,iBAA7B,CAAJ,EAAqD;AACpD,UAAME,aAAa,GAAGF,iBAAiB,CAACG,OAAlB,CAA0B,GAA1B,CAAtB;AACA,QAAIC,QAAQ,GACXF,aAAa,KAAK,CAAC,CAAnB,GACGF,iBADH,GAEGA,iBAAiB,CAACK,KAAlB,CAAwB,CAAxB,EAA2BH,aAA3B,CAHJ;AAIAE,IAAAA,QAAQ,GAAGd,IAAI,CAACmB,KAAL,CAAWF,QAAX,CAAoBR,OAApB,EAA6BK,QAA7B,CAAX;;AACA,QAAI,CAACZ,uBAAuB,CAACgB,IAAxB,CAA6BJ,QAA7B,CAAL,EAA6C;AAC5CA,MAAAA,QAAQ,GAAGT,qBAAqB,CAC/BS,QAAQ,CAACM,OAAT,CAAiBhB,6BAAjB,EAAgD,GAAhD,CAD+B,CAAhC;AAGA;;AACD,WAAOQ,aAAa,KAAK,CAAC,CAAnB,GACJE,QADI,GAEJA,QAAQ,GAAGJ,iBAAiB,CAACK,KAAlB,CAAwBH,aAAxB,CAFd;AAGA,GArCwD,CAuCzD;;;AACA,SAAOF,iBAAP;AACA,CAzCD;AA2CA;AACA;AACA;AACA;AACA;;;AACA,MAAMW,iBAAiB,GAAG,CAACZ,OAAD,EAAUH,YAAV,KAA2B;AACpD,MAAIA,YAAY,CAACC,UAAb,CAAwB,IAAxB,KAAiCD,YAAY,CAACC,UAAb,CAAwB,KAAxB,CAArC,EACC,OAAOP,IAAI,CAACsB,IAAL,CAAUb,OAAV,EAAmBH,YAAnB,CAAP;AACD,SAAOA,YAAP;AACA,CAJD;;AAMA,MAAMiB,aAAa,GAAGC,EAAE,IAAI;AAC3B;AACA,QAAMC,KAAK,GAAG,IAAIC,OAAJ,EAAd;AAEA;AACD;AACA;AACA;AACA;AACA;;AACC,QAAMC,QAAQ,GAAG,CAAClB,OAAD,EAAUmB,UAAV,EAAsBC,wBAAtB,KAAmD;AACnE,QAAI,CAACA,wBAAL,EAA+B,OAAOL,EAAE,CAACf,OAAD,EAAUmB,UAAV,CAAT;AAE/B,QAAIE,UAAU,GAAGL,KAAK,CAACM,GAAN,CAAUF,wBAAV,CAAjB;;AACA,QAAIC,UAAU,KAAKE,SAAnB,EAA8B;AAC7BF,MAAAA,UAAU,GAAG,IAAIG,GAAJ,EAAb;AACAR,MAAAA,KAAK,CAACS,GAAN,CAAUL,wBAAV,EAAoCC,UAApC;AACA;;AAED,QAAIK,YAAJ;AACA,QAAIC,aAAa,GAAGN,UAAU,CAACC,GAAX,CAAetB,OAAf,CAApB;;AACA,QAAI2B,aAAa,KAAKJ,SAAtB,EAAiC;AAChCF,MAAAA,UAAU,CAACI,GAAX,CAAezB,OAAf,EAAyB2B,aAAa,GAAG,IAAIH,GAAJ,EAAzC;AACA,KAFD,MAEO;AACNE,MAAAA,YAAY,GAAGC,aAAa,CAACL,GAAd,CAAkBH,UAAlB,CAAf;AACA;;AAED,QAAIO,YAAY,KAAKH,SAArB,EAAgC;AAC/B,aAAOG,YAAP;AACA,KAFD,MAEO;AACN,YAAME,MAAM,GAAGb,EAAE,CAACf,OAAD,EAAUmB,UAAV,CAAjB;AACAQ,MAAAA,aAAa,CAACF,GAAd,CAAkBN,UAAlB,EAA8BS,MAA9B;AACA,aAAOA,MAAP;AACA;AACD,GAxBD;AA0BA;AACD;AACA;AACA;;;AACCV,EAAAA,QAAQ,CAACW,SAAT,GAAqBT,wBAAwB,IAAI;AAChD,QAAIC,UAAJ;;AACA,QAAID,wBAAJ,EAA8B;AAC7BC,MAAAA,UAAU,GAAGL,KAAK,CAACM,GAAN,CAAUF,wBAAV,CAAb;;AACA,UAAIC,UAAU,KAAKE,SAAnB,EAA8B;AAC7BF,QAAAA,UAAU,GAAG,IAAIG,GAAJ,EAAb;AACAR,QAAAA,KAAK,CAACS,GAAN,CAAUL,wBAAV,EAAoCC,UAApC;AACA;AACD,KAND,MAMO;AACNA,MAAAA,UAAU,GAAG,IAAIG,GAAJ,EAAb;AACA;AAED;AACF;AACA;AACA;AACA;;;AACE,UAAMM,OAAO,GAAG,CAAC9B,OAAD,EAAUmB,UAAV,KAAyB;AACxC,UAAIO,YAAJ;AACA,UAAIC,aAAa,GAAGN,UAAU,CAACC,GAAX,CAAetB,OAAf,CAApB;;AACA,UAAI2B,aAAa,KAAKJ,SAAtB,EAAiC;AAChCF,QAAAA,UAAU,CAACI,GAAX,CAAezB,OAAf,EAAyB2B,aAAa,GAAG,IAAIH,GAAJ,EAAzC;AACA,OAFD,MAEO;AACNE,QAAAA,YAAY,GAAGC,aAAa,CAACL,GAAd,CAAkBH,UAAlB,CAAf;AACA;;AAED,UAAIO,YAAY,KAAKH,SAArB,EAAgC;AAC/B,eAAOG,YAAP;AACA,OAFD,MAEO;AACN,cAAME,MAAM,GAAGb,EAAE,CAACf,OAAD,EAAUmB,UAAV,CAAjB;AACAQ,QAAAA,aAAa,CAACF,GAAd,CAAkBN,UAAlB,EAA8BS,MAA9B;AACA,eAAOA,MAAP;AACA;AACD,KAhBD;;AAkBA,WAAOE,OAAP;AACA,GApCD;AAsCA;AACD;AACA;AACA;AACA;;;AACCZ,EAAAA,QAAQ,CAACa,gBAAT,GAA4B,CAAC/B,OAAD,EAAUoB,wBAAV,KAAuC;AAClE,QAAIO,aAAJ;;AACA,QAAIP,wBAAJ,EAA8B;AAC7B,UAAIC,UAAU,GAAGL,KAAK,CAACM,GAAN,CAAUF,wBAAV,CAAjB;;AACA,UAAIC,UAAU,KAAKE,SAAnB,EAA8B;AAC7BF,QAAAA,UAAU,GAAG,IAAIG,GAAJ,EAAb;AACAR,QAAAA,KAAK,CAACS,GAAN,CAAUL,wBAAV,EAAoCC,UAApC;AACA;;AAEDM,MAAAA,aAAa,GAAGN,UAAU,CAACC,GAAX,CAAetB,OAAf,CAAhB;;AACA,UAAI2B,aAAa,KAAKJ,SAAtB,EAAiC;AAChCF,QAAAA,UAAU,CAACI,GAAX,CAAezB,OAAf,EAAyB2B,aAAa,GAAG,IAAIH,GAAJ,EAAzC;AACA;AACD,KAXD,MAWO;AACNG,MAAAA,aAAa,GAAG,IAAIH,GAAJ,EAAhB;AACA;AAED;AACF;AACA;AACA;;;AACE,UAAMM,OAAO,GAAGX,UAAU,IAAI;AAC7B,YAAMO,YAAY,GAAGC,aAAa,CAACL,GAAd,CAAkBH,UAAlB,CAArB;;AACA,UAAIO,YAAY,KAAKH,SAArB,EAAgC;AAC/B,eAAOG,YAAP;AACA,OAFD,MAEO;AACN,cAAME,MAAM,GAAGb,EAAE,CAACf,OAAD,EAAUmB,UAAV,CAAjB;AACAQ,QAAAA,aAAa,CAACF,GAAd,CAAkBN,UAAlB,EAA8BS,MAA9B;AACA,eAAOA,MAAP;AACA;AACD,KATD;;AAWA,WAAOE,OAAP;AACA,GAjCD;;AAmCA,SAAOZ,QAAP;AACA,CAvHD;AAyHA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMc,kBAAkB,GAAG,CAAChC,OAAD,EAAUmB,UAAV,KAAyB;AACnD,SAAOA,UAAU,CACfc,KADK,CACCvC,qBADD,EAELwC,GAFK,CAEDC,GAAG,IAAIpC,iBAAiB,CAACC,OAAD,EAAUmC,GAAV,CAFvB,EAGLtB,IAHK,CAGA,EAHA,CAAP;AAIA,CALD;;AAOAuB,OAAO,CAACC,iBAAR,GAA4BvB,aAAa,CAACkB,kBAAD,CAAzC;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMM,kBAAkB,GAAG,CAACtC,OAAD,EAAUmB,UAAV,KAAyB;AACnD,SAAOA,UAAU,CACfc,KADK,CACCvC,qBADD,EAELwC,GAFK,CAEDC,GAAG,IAAIvB,iBAAiB,CAACZ,OAAD,EAAUmC,GAAV,CAFvB,EAGLtB,IAHK,CAGA,EAHA,CAAP;AAIA,CALD;;AAOAuB,OAAO,CAACG,iBAAR,GAA4BzB,aAAa,CAACwB,kBAAD,CAAzC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAME,WAAW,GAAG,CAACxC,OAAD,EAAUyC,OAAV,KAAsB;AACzC,SAAOA,OAAO,CACZR,KADK,CACC,GADD,EAELC,GAFK,CAEDQ,CAAC,IAAI3C,iBAAiB,CAACC,OAAD,EAAU0C,CAAV,CAFrB,EAGL7B,IAHK,CAGA,GAHA,CAAP;AAIA,CALD;;AAOA,MAAM8B,UAAU,GAAG7B,aAAa,CAAC0B,WAAD,CAAhC;AACAJ,OAAO,CAACO,UAAR,GAAqBA,UAArB;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,CAAC5C,OAAD,EAAUyC,OAAV,KAAsB;AACzC,SAAOA,OAAO,CACZR,KADK,CACC,GADD,EAELC,GAFK,CAEDQ,CAAC,IAAI9B,iBAAiB,CAACZ,OAAD,EAAU0C,CAAV,CAFrB,EAGL7B,IAHK,CAGA,GAHA,CAAP;AAIA,CALD;;AAOA,MAAMgC,UAAU,GAAG/B,aAAa,CAAC8B,WAAD,CAAhC;AACAR,OAAO,CAACS,UAAR,GAAqBA,UAArB;AAEA,MAAMC,0BAA0B,GAC/B,gDADD;AAGA;;AAEA;AACA;AACA;AACA;;AACA,MAAMC,cAAc,GAAGZ,GAAG,IAAI;AAC7B,QAAMa,KAAK,GAAGF,0BAA0B,CAACG,IAA3B,CAAgCd,GAAhC,CAAd;AACA,SAAO;AACN9B,IAAAA,QAAQ,EAAE8B,GADJ;AAEN5C,IAAAA,IAAI,EAAEyD,KAAK,CAAC,CAAD,CAAL,CAASrC,OAAT,CAAiB,QAAjB,EAA2B,IAA3B,CAFA;AAGNuC,IAAAA,KAAK,EAAEF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,CAASrC,OAAT,CAAiB,QAAjB,EAA2B,IAA3B,CAAX,GAA8C,EAH/C;AAINwC,IAAAA,QAAQ,EAAEH,KAAK,CAAC,CAAD,CAAL,IAAY;AAJhB,GAAP;AAMA,CARD;;AASAZ,OAAO,CAACgB,aAAR,GAAwB,CAACC,MAAM,IAAI;AAClC;AACA,QAAMrC,KAAK,GAAG,IAAIC,OAAJ,EAAd;;AAEA,QAAMqC,QAAQ,GAAGlC,wBAAwB,IAAI;AAC5C,UAAMmC,KAAK,GAAGvC,KAAK,CAACM,GAAN,CAAUF,wBAAV,CAAd;AACA,QAAImC,KAAK,KAAKhC,SAAd,EAAyB,OAAOgC,KAAP;AACzB;;AACA,UAAMrB,GAAG,GAAG,IAAIV,GAAJ,EAAZ;AACAR,IAAAA,KAAK,CAACS,GAAN,CAAUL,wBAAV,EAAoCc,GAApC;AACA,WAAOA,GAAP;AACA,GAPD;AASA;AACD;AACA;AACA;AACA;;;AACC,QAAMnB,EAAE,GAAG,CAACoB,GAAD,EAAMf,wBAAN,KAAmC;AAC7C,QAAI,CAACA,wBAAL,EAA+B,OAAOiC,MAAM,CAAClB,GAAD,CAAb;AAC/B,UAAMnB,KAAK,GAAGsC,QAAQ,CAAClC,wBAAD,CAAtB;AACA,UAAMmC,KAAK,GAAGvC,KAAK,CAACM,GAAN,CAAUa,GAAV,CAAd;AACA,QAAIoB,KAAK,KAAKhC,SAAd,EAAyB,OAAOgC,KAAP;AACzB,UAAM3B,MAAM,GAAGyB,MAAM,CAAClB,GAAD,CAArB;AACAnB,IAAAA,KAAK,CAACS,GAAN,CAAUU,GAAV,EAAeP,MAAf;AACA,WAAOA,MAAP;AACA,GARD;;AAUAb,EAAAA,EAAE,CAACc,SAAH,GAAeT,wBAAwB,IAAI;AAC1C,UAAMJ,KAAK,GAAGsC,QAAQ,CAAClC,wBAAD,CAAtB;AACA,WAAOe,GAAG,IAAI;AACb,YAAMoB,KAAK,GAAGvC,KAAK,CAACM,GAAN,CAAUa,GAAV,CAAd;AACA,UAAIoB,KAAK,KAAKhC,SAAd,EAAyB,OAAOgC,KAAP;AACzB,YAAM3B,MAAM,GAAGyB,MAAM,CAAClB,GAAD,CAArB;AACAnB,MAAAA,KAAK,CAACS,GAAN,CAAUU,GAAV,EAAeP,MAAf;AACA,aAAOA,MAAP;AACA,KAND;AAOA,GATD;;AAWA,SAAOb,EAAP;AACA,CAxCuB,EAwCrBgC,cAxCqB,CAAxB;AA0CA;AACA;AACA;AACA;AACA;AACA;;;AACAX,OAAO,CAACoB,WAAR,GAAsB,CAACC,QAAD,EAAWC,UAAX,EAAuBC,eAAvB,KAA2C;AAChE,MAAIC,KAAK,GAAG,CAAC,CAAb;AACA,MAAIC,MAAM,GAAG,EAAb;AACAH,EAAAA,UAAU,GAAGA,UAAU,CAAC/C,OAAX,CAAmB,QAAnB,EAA6B,EAA7B,CAAb;;AACA,OAAK,MAAMmD,IAAX,IAAmBL,QAAQ,CAACxB,KAAT,CAAe,QAAf,CAAnB,EAA6C;AAC5C,QAAI6B,IAAI,KAAK,IAAb,EAAmB;AAClB,UAAIF,KAAK,GAAG,CAAC,CAAb,EAAgB;AACfA,QAAAA,KAAK;AACL,OAFD,MAEO;AACN,cAAMG,CAAC,GAAGL,UAAU,CAACM,WAAX,CAAuB,GAAvB,CAAV;AACA,cAAMC,CAAC,GAAGP,UAAU,CAACM,WAAX,CAAuB,IAAvB,CAAV;AACA,cAAME,GAAG,GAAGH,CAAC,GAAG,CAAJ,GAAQE,CAAR,GAAYA,CAAC,GAAG,CAAJ,GAAQF,CAAR,GAAYI,IAAI,CAACC,GAAL,CAASL,CAAT,EAAYE,CAAZ,CAApC;AACA,YAAIC,GAAG,GAAG,CAAV,EAAa,OAAOR,UAAU,GAAG,GAApB;AACbG,QAAAA,MAAM,GAAGH,UAAU,CAACpD,KAAX,CAAiB4D,GAAG,GAAG,CAAvB,IAA4B,GAA5B,GAAkCL,MAA3C;AACAH,QAAAA,UAAU,GAAGA,UAAU,CAACpD,KAAX,CAAiB,CAAjB,EAAoB4D,GAApB,CAAb;AACA;AACD,KAXD,MAWO,IAAIJ,IAAI,KAAK,GAAb,EAAkB;AACxBF,MAAAA,KAAK;AACL;AACD;;AACD,SAAOA,KAAK,GAAG,CAAR,GACH,GAAE,MAAMS,MAAN,CAAaT,KAAb,CAAoB,GAAEC,MAAO,EAD5B,GAEJF,eAAe,GACd,KAAIE,MAAO,EADG,GAEfA,MAJH;AAKA,CAzBD","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n\tif (relativePath === \"\") return \"./.\";\n\tif (relativePath === \"..\") return \"../.\";\n\tif (relativePath.startsWith(\"../\")) return relativePath;\n\treturn `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n\tif (maybeAbsolutePath[0] === \"/\") {\n\t\tif (\n\t\t\tmaybeAbsolutePath.length > 1 &&\n\t\t\tmaybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\"\n\t\t) {\n\t\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t\t// Don't treat it as an absolute path.\n\t\t\treturn maybeAbsolutePath;\n\t\t}\n\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = relativePathToRequest(path.posix.relative(context, resource));\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\tif (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = path.win32.relative(context, resource);\n\t\tif (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n\t\t\tresource = relativePathToRequest(\n\t\t\t\tresource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\")\n\t\t\t);\n\t\t}\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\t// not an absolute path\n\treturn maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\nconst makeCacheable = fn => {\n\t/** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n\tconst cache = new WeakMap();\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {string} identifier identifier used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {string} the returned relative path\n\t */\n\tconst cachedFn = (context, identifier, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return fn(context, identifier);\n\n\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\tif (innerCache === undefined) {\n\t\t\tinnerCache = new Map();\n\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t}\n\n\t\tlet cachedResult;\n\t\tlet innerSubCache = innerCache.get(context);\n\t\tif (innerSubCache === undefined) {\n\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t} else {\n\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t}\n\n\t\tif (cachedResult !== undefined) {\n\t\t\treturn cachedResult;\n\t\t} else {\n\t\t\tconst result = fn(context, identifier);\n\t\t\tinnerSubCache.set(identifier, result);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string, string): string} cached function\n\t */\n\tcachedFn.bindCache = associatedObjectForCache => {\n\t\tlet innerCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tinnerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\t\t} else {\n\t\t\tinnerCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} context context used to create relative path\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = (context, identifier) => {\n\t\t\tlet cachedResult;\n\t\t\tlet innerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t} else {\n\t\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t\t}\n\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string): string} cached function\n\t */\n\tcachedFn.bindContextCache = (context, associatedObjectForCache) => {\n\t\tlet innerSubCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\n\t\t\tinnerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t}\n\t\t} else {\n\t\t\tinnerSubCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = identifier => {\n\t\t\tconst cachedResult = innerSubCache.get(identifier);\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\treturn cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => absoluteToRequest(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsRelative = makeCacheable(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => requestToAbsolute(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheable(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => absoluteToRequest(context, r))\n\t\t.join(\"!\");\n};\n\nconst contextify = makeCacheable(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nconst absolutify = makeCacheable(_absolutify);\nexports.absolutify = absolutify;\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n\t\tfragment: match[3] || \"\"\n\t};\n};\nexports.parseResource = (realFn => {\n\t/** @type {WeakMap<object, Map<string, ParsedResource>>} */\n\tconst cache = new WeakMap();\n\n\tconst getCache = associatedObjectForCache => {\n\t\tconst entry = cache.get(associatedObjectForCache);\n\t\tif (entry !== undefined) return entry;\n\t\t/** @type {Map<string, ParsedResource>} */\n\t\tconst map = new Map();\n\t\tcache.set(associatedObjectForCache, map);\n\t\treturn map;\n\t};\n\n\t/**\n\t * @param {string} str the path with query and fragment\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {ParsedResource} parsed parts\n\t */\n\tconst fn = (str, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return realFn(str);\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\tconst entry = cache.get(str);\n\t\tif (entry !== undefined) return entry;\n\t\tconst result = realFn(str);\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n\n\tfn.bindCache = associatedObjectForCache => {\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\treturn str => {\n\t\t\tconst entry = cache.get(str);\n\t\t\tif (entry !== undefined) return entry;\n\t\t\tconst result = realFn(str);\n\t\t\tcache.set(str, result);\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn fn;\n})(_parseResource);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n\tlet depth = -1;\n\tlet append = \"\";\n\toutputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\tfor (const part of filename.split(/[/\\\\]+/)) {\n\t\tif (part === \"..\") {\n\t\t\tif (depth > -1) {\n\t\t\t\tdepth--;\n\t\t\t} else {\n\t\t\t\tconst i = outputPath.lastIndexOf(\"/\");\n\t\t\t\tconst j = outputPath.lastIndexOf(\"\\\\\");\n\t\t\t\tconst pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n\t\t\t\tif (pos < 0) return outputPath + \"/\";\n\t\t\t\tappend = outputPath.slice(pos + 1) + \"/\" + append;\n\t\t\t\toutputPath = outputPath.slice(0, pos);\n\t\t\t}\n\t\t} else if (part !== \".\") {\n\t\t\tdepth++;\n\t\t}\n\t}\n\treturn depth > 0\n\t\t? `${\"../\".repeat(depth)}${append}`\n\t\t: enforceRelative\n\t\t? `./${append}`\n\t\t: append;\n};\n"]},"metadata":{},"sourceType":"script"}