{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst ContextModule = require(\"./ContextModule\");\n\nconst ModuleFactory = require(\"./ModuleFactory\");\n\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n\nconst LazySet = require(\"./util/LazySet\");\n\nconst {\n  cachedSetProperty\n} = require(\"./util/cleverMerge\");\n\nconst {\n  createFakeHook\n} = require(\"./util/deprecation\");\n\nconst {\n  join\n} = require(\"./util/fs\");\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  constructor(resolverFactory) {\n    super();\n    /** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\n    const alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n        intercept: interceptor => {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n        tap: (options, fn) => {\n          alternativeRequests.tap(options, fn);\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n        tapAsync: (options, fn) => {\n          alternativeRequests.tapAsync(options, (items, _options, callback) => fn(items, callback));\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n        tapPromise: (options, fn) => {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests\n    });\n    this.resolverFactory = resolverFactory;\n  }\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n\n\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency =\n    /** @type {ContextDependency} */\n    dependencies[0];\n    const fileDependencies = new LazySet();\n    const missingDependencies = new LazySet();\n    const contextDependencies = new LazySet();\n    this.hooks.beforeResolve.callAsync({\n      context: context,\n      dependencies: dependencies,\n      resolveOptions,\n      fileDependencies,\n      missingDependencies,\n      contextDependencies,\n      ...dependency.options\n    }, (err, beforeResolveResult) => {\n      if (err) {\n        return callback(err, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      } // Ignored\n\n\n      if (!beforeResolveResult) {\n        return callback(null, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n          resource,\n          loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n\n      if (idx >= 0) {\n        let loadersRequest = request.substr(0, idx + 1);\n        let i;\n\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n\n        loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n\n        resource = request.substr(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n\n      const contextResolver = this.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n      const loaderResolver = this.resolverFactory.get(\"loader\");\n      asyncLib.parallel([callback => {\n        contextResolver.resolve({}, context, resource, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        }, (err, result) => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          }, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) {\n          return callback(err, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        }\n\n        this.hooks.afterResolve.callAsync({\n          addon: loadersPrefix + result[1].join(\"!\") + (result[1].length > 0 ? \"!\" : \"\"),\n          resource: result[0],\n          resolveDependencies: this.resolveDependencies.bind(this),\n          ...beforeResolveResult\n        }, (err, result) => {\n          if (err) {\n            return callback(err, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          } // Ignored\n\n\n          if (!result) {\n            return callback(null, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n\n          return callback(null, {\n            module: new ContextModule(result.resolveDependencies, result),\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {ContextModuleOptions} options options\n   * @param {ResolveDependenciesCallback} callback callback function\n   * @returns {void}\n   */\n\n\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    const {\n      resource,\n      resourceQuery,\n      resourceFragment,\n      recursive,\n      regExp,\n      include,\n      exclude,\n      referencedExports,\n      category,\n      typePrefix\n    } = options;\n    if (!regExp || !resource) return callback(null, []);\n\n    const addDirectoryChecked = (directory, visited, callback) => {\n      fs.realpath(directory, (err, realPath) => {\n        if (err) return callback(err);\n        if (visited.has(realPath)) return callback(null, []);\n        let recursionStack;\n        addDirectory(directory, (dir, callback) => {\n          if (recursionStack === undefined) {\n            recursionStack = new Set(visited);\n            recursionStack.add(realPath);\n          }\n\n          addDirectoryChecked(dir, recursionStack, callback);\n        }, callback);\n      });\n    };\n\n    const addDirectory = (directory, addSubDirectory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        const processedFiles = cmf.hooks.contextModuleFiles.call(\n        /** @type {string[]} */\n        files.map(file => file.normalize(\"NFC\")));\n        if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n        asyncLib.map(processedFiles.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = join(fs, directory, segment);\n\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addSubDirectory(subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: resource,\n                  request: \".\" + subResource.substr(resource.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternativeRequests.callAsync([obj], options, (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(obj.request + resourceQuery + resourceFragment, obj.request, typePrefix, category, referencedExports);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          const flattenedResult = [];\n\n          for (const item of result) {\n            if (item) flattenedResult.push(...item);\n          }\n\n          callback(null, flattenedResult);\n        });\n      });\n    };\n\n    if (typeof fs.realpath === \"function\") {\n      addDirectoryChecked(resource, new Set(), callback);\n    } else {\n      const addSubDirectory = (dir, callback) => addDirectory(dir, addSubDirectory, callback);\n\n      addDirectory(resource, addSubDirectory, callback);\n    }\n  }\n\n};","map":{"version":3,"sources":["E:/Coding/fixl solution/work1/addtocart/node_modules/webpack/lib/ContextModuleFactory.js"],"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","create","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","substr","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","resolve","result","map","loader","addon","resolveDependencies","bind","fs","cmf","resourceQuery","resourceFragment","recursive","regExp","include","exclude","referencedExports","typePrefix","addDirectoryChecked","directory","visited","realpath","realPath","has","recursionStack","addDirectory","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","filter","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","obj","test","dep","optional","flattenedResult","item","push"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAM;AAAEC,EAAAA,wBAAF;AAA4BC,EAAAA;AAA5B,IAAkDF,OAAO,CAAC,SAAD,CAA/D;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMK,wBAAwB,GAAGL,OAAO,CAAC,yCAAD,CAAxC;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAwBP,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAM;AAAEQ,EAAAA;AAAF,IAAqBR,OAAO,CAAC,oBAAD,CAAlC;;AACA,MAAM;AAAES,EAAAA;AAAF,IAAWT,OAAO,CAAC,WAAD,CAAxB;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;AAEA,MAAMU,qBAAqB,GAAG,EAA9B;AAEAC,MAAM,CAACC,OAAP,GAAiB,MAAMC,oBAAN,SAAmCT,aAAnC,CAAiD;AACjE;AACD;AACA;AACCU,EAAAA,WAAW,CAACC,eAAD,EAAkB;AAC5B;AACA;;AACA,UAAMC,mBAAmB,GAAG,IAAIf,wBAAJ,CAA6B,CACxD,SADwD,EAExD,SAFwD,CAA7B,CAA5B;AAIA,SAAKgB,KAAL,GAAaC,MAAM,CAACC,MAAP,CAAc;AAC1B;AACAC,MAAAA,aAAa,EAAE,IAAInB,wBAAJ,CAA6B,CAAC,MAAD,CAA7B,CAFW;;AAG1B;AACAoB,MAAAA,YAAY,EAAE,IAAIpB,wBAAJ,CAA6B,CAAC,MAAD,CAA7B,CAJY;;AAK1B;AACAqB,MAAAA,kBAAkB,EAAE,IAAIpB,iBAAJ,CAAsB,CAAC,OAAD,CAAtB,CANM;;AAO1B;AACAqB,MAAAA,YAAY,EAAEf,cAAc,CAC3B;AACCgB,QAAAA,IAAI,EAAE,cADP;;AAEC;AACAC,QAAAA,SAAS,EAAEC,WAAW,IAAI;AACzB,gBAAM,IAAIC,KAAJ,CACL,4IADK,CAAN;AAGA,SAPF;;AAQC;AACAC,QAAAA,GAAG,EAAE,CAACC,OAAD,EAAUC,EAAV,KAAiB;AACrBd,UAAAA,mBAAmB,CAACY,GAApB,CAAwBC,OAAxB,EAAiCC,EAAjC;AACA,SAXF;;AAYC;AACAC,QAAAA,QAAQ,EAAE,CAACF,OAAD,EAAUC,EAAV,KAAiB;AAC1Bd,UAAAA,mBAAmB,CAACe,QAApB,CAA6BF,OAA7B,EAAsC,CAACG,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,KACrCJ,EAAE,CAACE,KAAD,EAAQE,QAAR,CADH;AAGA,SAjBF;;AAkBC;AACAC,QAAAA,UAAU,EAAE,CAACN,OAAD,EAAUC,EAAV,KAAiB;AAC5Bd,UAAAA,mBAAmB,CAACmB,UAApB,CAA+BN,OAA/B,EAAwCC,EAAxC;AACA;AArBF,OAD2B,EAwB3B,wJAxB2B,EAyB3B,iDAzB2B,CARF;AAmC1Bd,MAAAA;AAnC0B,KAAd,CAAb;AAqCA,SAAKD,eAAL,GAAuBA,eAAvB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACCqB,EAAAA,MAAM,CAACC,IAAD,EAAOH,QAAP,EAAiB;AACtB,UAAMI,OAAO,GAAGD,IAAI,CAACC,OAArB;AACA,UAAMC,YAAY,GAAGF,IAAI,CAACE,YAA1B;AACA,UAAMC,cAAc,GAAGH,IAAI,CAACG,cAA5B;AACA,UAAMC,UAAU;AAAG;AAAkCF,IAAAA,YAAY,CAAC,CAAD,CAAjE;AACA,UAAMG,gBAAgB,GAAG,IAAIpC,OAAJ,EAAzB;AACA,UAAMqC,mBAAmB,GAAG,IAAIrC,OAAJ,EAA5B;AACA,UAAMsC,mBAAmB,GAAG,IAAItC,OAAJ,EAA5B;AACA,SAAKW,KAAL,CAAWG,aAAX,CAAyByB,SAAzB,CACC;AACCP,MAAAA,OAAO,EAAEA,OADV;AAECC,MAAAA,YAAY,EAAEA,YAFf;AAGCC,MAAAA,cAHD;AAICE,MAAAA,gBAJD;AAKCC,MAAAA,mBALD;AAMCC,MAAAA,mBAND;AAOC,SAAGH,UAAU,CAACZ;AAPf,KADD,EAUC,CAACiB,GAAD,EAAMC,mBAAN,KAA8B;AAC7B,UAAID,GAAJ,EAAS;AACR,eAAOZ,QAAQ,CAACY,GAAD,EAAM;AACpBJ,UAAAA,gBADoB;AAEpBC,UAAAA,mBAFoB;AAGpBC,UAAAA;AAHoB,SAAN,CAAf;AAKA,OAP4B,CAS7B;;;AACA,UAAI,CAACG,mBAAL,EAA0B;AACzB,eAAOb,QAAQ,CAAC,IAAD,EAAO;AACrBQ,UAAAA,gBADqB;AAErBC,UAAAA,mBAFqB;AAGrBC,UAAAA;AAHqB,SAAP,CAAf;AAKA;;AAED,YAAMN,OAAO,GAAGS,mBAAmB,CAACT,OAApC;AACA,YAAMU,OAAO,GAAGD,mBAAmB,CAACC,OAApC;AACA,YAAMR,cAAc,GAAGO,mBAAmB,CAACP,cAA3C;AAEA,UAAIS,OAAJ;AAAA,UACCC,QADD;AAAA,UAECC,aAAa,GAAG,EAFjB;AAGA,YAAMC,GAAG,GAAGJ,OAAO,CAACK,WAAR,CAAoB,GAApB,CAAZ;;AACA,UAAID,GAAG,IAAI,CAAX,EAAc;AACb,YAAIE,cAAc,GAAGN,OAAO,CAACO,MAAR,CAAe,CAAf,EAAkBH,GAAG,GAAG,CAAxB,CAArB;AACA,YAAII,CAAJ;;AACA,aACCA,CAAC,GAAG,CADL,EAECA,CAAC,GAAGF,cAAc,CAACG,MAAnB,IAA6BH,cAAc,CAACE,CAAD,CAAd,KAAsB,GAFpD,EAGCA,CAAC,EAHF,EAIE;AACDL,UAAAA,aAAa,IAAI,GAAjB;AACA;;AACDG,QAAAA,cAAc,GAAGA,cAAc,CAC7BC,MADe,CACRC,CADQ,EAEfE,OAFe,CAEP,KAFO,EAEA,EAFA,EAGfA,OAHe,CAGP,MAHO,EAGC,GAHD,CAAjB;;AAIA,YAAIJ,cAAc,KAAK,EAAvB,EAA2B;AAC1BL,UAAAA,OAAO,GAAG,EAAV;AACA,SAFD,MAEO;AACNA,UAAAA,OAAO,GAAGK,cAAc,CAACK,KAAf,CAAqB,GAArB,CAAV;AACA;;AACDT,QAAAA,QAAQ,GAAGF,OAAO,CAACO,MAAR,CAAeH,GAAG,GAAG,CAArB,CAAX;AACA,OApBD,MAoBO;AACNH,QAAAA,OAAO,GAAG,EAAV;AACAC,QAAAA,QAAQ,GAAGF,OAAX;AACA;;AAED,YAAMY,eAAe,GAAG,KAAK7C,eAAL,CAAqB8C,GAArB,CACvB,SADuB,EAEvBtB,YAAY,CAACkB,MAAb,GAAsB,CAAtB,GACGlD,iBAAiB,CACjBiC,cAAc,IAAI9B,qBADD,EAEjB,gBAFiB,EAGjB6B,YAAY,CAAC,CAAD,CAAZ,CAAgBuB,QAHC,CADpB,GAMGtB,cARoB,CAAxB;AAUA,YAAMuB,cAAc,GAAG,KAAKhD,eAAL,CAAqB8C,GAArB,CAAyB,QAAzB,CAAvB;AAEA9D,MAAAA,QAAQ,CAACiE,QAAT,CACC,CACC9B,QAAQ,IAAI;AACX0B,QAAAA,eAAe,CAACK,OAAhB,CACC,EADD,EAEC3B,OAFD,EAGCY,QAHD,EAIC;AACCR,UAAAA,gBADD;AAECC,UAAAA,mBAFD;AAGCC,UAAAA;AAHD,SAJD,EASC,CAACE,GAAD,EAAMoB,MAAN,KAAiB;AAChB,cAAIpB,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACTZ,UAAAA,QAAQ,CAAC,IAAD,EAAOgC,MAAP,CAAR;AACA,SAZF;AAcA,OAhBF,EAiBChC,QAAQ,IAAI;AACXnC,QAAAA,QAAQ,CAACoE,GAAT,CACClB,OADD,EAEC,CAACmB,MAAD,EAASlC,QAAT,KAAsB;AACrB6B,UAAAA,cAAc,CAACE,OAAf,CACC,EADD,EAEC3B,OAFD,EAGC8B,MAHD,EAIC;AACC1B,YAAAA,gBADD;AAECC,YAAAA,mBAFD;AAGCC,YAAAA;AAHD,WAJD,EASC,CAACE,GAAD,EAAMoB,MAAN,KAAiB;AAChB,gBAAIpB,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACTZ,YAAAA,QAAQ,CAAC,IAAD,EAAOgC,MAAP,CAAR;AACA,WAZF;AAcA,SAjBF,EAkBChC,QAlBD;AAoBA,OAtCF,CADD,EAyCC,CAACY,GAAD,EAAMoB,MAAN,KAAiB;AAChB,YAAIpB,GAAJ,EAAS;AACR,iBAAOZ,QAAQ,CAACY,GAAD,EAAM;AACpBJ,YAAAA,gBADoB;AAEpBC,YAAAA,mBAFoB;AAGpBC,YAAAA;AAHoB,WAAN,CAAf;AAKA;;AAED,aAAK3B,KAAL,CAAWI,YAAX,CAAwBwB,SAAxB,CACC;AACCwB,UAAAA,KAAK,EACJlB,aAAa,GACbe,MAAM,CAAC,CAAD,CAAN,CAAUzD,IAAV,CAAe,GAAf,CADA,IAECyD,MAAM,CAAC,CAAD,CAAN,CAAUT,MAAV,GAAmB,CAAnB,GAAuB,GAAvB,GAA6B,EAF9B,CAFF;AAKCP,UAAAA,QAAQ,EAAEgB,MAAM,CAAC,CAAD,CALjB;AAMCI,UAAAA,mBAAmB,EAAE,KAAKA,mBAAL,CAAyBC,IAAzB,CAA8B,IAA9B,CANtB;AAOC,aAAGxB;AAPJ,SADD,EAUC,CAACD,GAAD,EAAMoB,MAAN,KAAiB;AAChB,cAAIpB,GAAJ,EAAS;AACR,mBAAOZ,QAAQ,CAACY,GAAD,EAAM;AACpBJ,cAAAA,gBADoB;AAEpBC,cAAAA,mBAFoB;AAGpBC,cAAAA;AAHoB,aAAN,CAAf;AAKA,WAPe,CAShB;;;AACA,cAAI,CAACsB,MAAL,EAAa;AACZ,mBAAOhC,QAAQ,CAAC,IAAD,EAAO;AACrBQ,cAAAA,gBADqB;AAErBC,cAAAA,mBAFqB;AAGrBC,cAAAA;AAHqB,aAAP,CAAf;AAKA;;AAED,iBAAOV,QAAQ,CAAC,IAAD,EAAO;AACrBvB,YAAAA,MAAM,EAAE,IAAIR,aAAJ,CAAkB+D,MAAM,CAACI,mBAAzB,EAA8CJ,MAA9C,CADa;AAErBxB,YAAAA,gBAFqB;AAGrBC,YAAAA,mBAHqB;AAIrBC,YAAAA;AAJqB,WAAP,CAAf;AAMA,SAlCF;AAoCA,OAtFF;AAwFA,KAjKF;AAmKA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACC0B,EAAAA,mBAAmB,CAACE,EAAD,EAAK3C,OAAL,EAAcK,QAAd,EAAwB;AAC1C,UAAMuC,GAAG,GAAG,IAAZ;AACA,UAAM;AACLvB,MAAAA,QADK;AAELwB,MAAAA,aAFK;AAGLC,MAAAA,gBAHK;AAILC,MAAAA,SAJK;AAKLC,MAAAA,MALK;AAMLC,MAAAA,OANK;AAOLC,MAAAA,OAPK;AAQLC,MAAAA,iBARK;AASLlB,MAAAA,QATK;AAULmB,MAAAA;AAVK,QAWFpD,OAXJ;AAYA,QAAI,CAACgD,MAAD,IAAW,CAAC3B,QAAhB,EAA0B,OAAOhB,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAf;;AAE1B,UAAMgD,mBAAmB,GAAG,CAACC,SAAD,EAAYC,OAAZ,EAAqBlD,QAArB,KAAkC;AAC7DsC,MAAAA,EAAE,CAACa,QAAH,CAAYF,SAAZ,EAAuB,CAACrC,GAAD,EAAMwC,QAAN,KAAmB;AACzC,YAAIxC,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACT,YAAIsC,OAAO,CAACG,GAAR,CAAYD,QAAZ,CAAJ,EAA2B,OAAOpD,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAf;AAC3B,YAAIsD,cAAJ;AACAC,QAAAA,YAAY,CACXN,SADW,EAEX,CAACO,GAAD,EAAMxD,QAAN,KAAmB;AAClB,cAAIsD,cAAc,KAAKG,SAAvB,EAAkC;AACjCH,YAAAA,cAAc,GAAG,IAAII,GAAJ,CAAQR,OAAR,CAAjB;AACAI,YAAAA,cAAc,CAACK,GAAf,CAAmBP,QAAnB;AACA;;AACDJ,UAAAA,mBAAmB,CAACQ,GAAD,EAAMF,cAAN,EAAsBtD,QAAtB,CAAnB;AACA,SARU,EASXA,QATW,CAAZ;AAWA,OAfD;AAgBA,KAjBD;;AAmBA,UAAMuD,YAAY,GAAG,CAACN,SAAD,EAAYW,eAAZ,EAA6B5D,QAA7B,KAA0C;AAC9DsC,MAAAA,EAAE,CAACuB,OAAH,CAAWZ,SAAX,EAAsB,CAACrC,GAAD,EAAMkD,KAAN,KAAgB;AACrC,YAAIlD,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACT,cAAMmD,cAAc,GAAGxB,GAAG,CAACxD,KAAJ,CAAUK,kBAAV,CAA6B4E,IAA7B;AACtB;AAAyBF,QAAAA,KAAD,CAAQ7B,GAAR,CAAYgC,IAAI,IAAIA,IAAI,CAACC,SAAL,CAAe,KAAf,CAApB,CADF,CAAvB;AAGA,YAAI,CAACH,cAAD,IAAmBA,cAAc,CAACxC,MAAf,KAA0B,CAAjD,EACC,OAAOvB,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAf;AACDnC,QAAAA,QAAQ,CAACoE,GAAT,CACC8B,cAAc,CAACI,MAAf,CAAsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,GAAV,MAAmB,CAA9C,CADD,EAEC,CAACC,OAAD,EAAUtE,QAAV,KAAuB;AACtB,gBAAMuE,WAAW,GAAGhG,IAAI,CAAC+D,EAAD,EAAKW,SAAL,EAAgBqB,OAAhB,CAAxB;;AAEA,cAAI,CAACzB,OAAD,IAAY,CAAC0B,WAAW,CAACC,KAAZ,CAAkB3B,OAAlB,CAAjB,EAA6C;AAC5CP,YAAAA,EAAE,CAACmC,IAAH,CAAQF,WAAR,EAAqB,CAAC3D,GAAD,EAAM6D,IAAN,KAAe;AACnC,kBAAI7D,GAAJ,EAAS;AACR,oBAAIA,GAAG,CAAC8D,IAAJ,KAAa,QAAjB,EAA2B;AAC1B;AACA;AACA,yBAAO1E,QAAQ,EAAf;AACA,iBAJD,MAIO;AACN,yBAAOA,QAAQ,CAACY,GAAD,CAAf;AACA;AACD;;AAED,kBAAI6D,IAAI,CAACE,WAAL,EAAJ,EAAwB;AACvB,oBAAI,CAACjC,SAAL,EAAgB,OAAO1C,QAAQ,EAAf;AAChB4D,gBAAAA,eAAe,CAACW,WAAD,EAAcvE,QAAd,CAAf;AACA,eAHD,MAGO,IACNyE,IAAI,CAACG,MAAL,OACC,CAAChC,OAAD,IAAY2B,WAAW,CAACC,KAAZ,CAAkB5B,OAAlB,CADb,CADM,EAGL;AACD,sBAAMiC,GAAG,GAAG;AACXzE,kBAAAA,OAAO,EAAEY,QADE;AAEXF,kBAAAA,OAAO,EACN,MACAyD,WAAW,CAAClD,MAAZ,CAAmBL,QAAQ,CAACO,MAA5B,EAAoCC,OAApC,CAA4C,KAA5C,EAAmD,GAAnD;AAJU,iBAAZ;AAOA,qBAAKzC,KAAL,CAAWD,mBAAX,CAA+B6B,SAA/B,CACC,CAACkE,GAAD,CADD,EAEClF,OAFD,EAGC,CAACiB,GAAD,EAAMvB,YAAN,KAAuB;AACtB,sBAAIuB,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACTvB,kBAAAA,YAAY,GAAGA,YAAY,CACzB8E,MADa,CACNU,GAAG,IAAIlC,MAAM,CAACmC,IAAP,CAAYD,GAAG,CAAC/D,OAAhB,CADD,EAEbmB,GAFa,CAET4C,GAAG,IAAI;AACX,0BAAME,GAAG,GAAG,IAAI5G,wBAAJ,CACX0G,GAAG,CAAC/D,OAAJ,GAAc0B,aAAd,GAA8BC,gBADnB,EAEXoC,GAAG,CAAC/D,OAFO,EAGXiC,UAHW,EAIXnB,QAJW,EAKXkB,iBALW,CAAZ;AAOAiC,oBAAAA,GAAG,CAACC,QAAJ,GAAe,IAAf;AACA,2BAAOD,GAAP;AACA,mBAZa,CAAf;AAaA/E,kBAAAA,QAAQ,CAAC,IAAD,EAAOX,YAAP,CAAR;AACA,iBAnBF;AAqBA,eAhCM,MAgCA;AACNW,gBAAAA,QAAQ;AACR;AACD,aAjDD;AAkDA,WAnDD,MAmDO;AACNA,YAAAA,QAAQ;AACR;AACD,SA3DF,EA4DC,CAACY,GAAD,EAAMoB,MAAN,KAAiB;AAChB,cAAIpB,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AAET,cAAI,CAACoB,MAAL,EAAa,OAAOhC,QAAQ,CAAC,IAAD,EAAO,EAAP,CAAf;AAEb,gBAAMiF,eAAe,GAAG,EAAxB;;AAEA,eAAK,MAAMC,IAAX,IAAmBlD,MAAnB,EAA2B;AAC1B,gBAAIkD,IAAJ,EAAUD,eAAe,CAACE,IAAhB,CAAqB,GAAGD,IAAxB;AACV;;AAEDlF,UAAAA,QAAQ,CAAC,IAAD,EAAOiF,eAAP,CAAR;AACA,SAxEF;AA0EA,OAjFD;AAkFA,KAnFD;;AAqFA,QAAI,OAAO3C,EAAE,CAACa,QAAV,KAAuB,UAA3B,EAAuC;AACtCH,MAAAA,mBAAmB,CAAChC,QAAD,EAAW,IAAI0C,GAAJ,EAAX,EAAsB1D,QAAtB,CAAnB;AACA,KAFD,MAEO;AACN,YAAM4D,eAAe,GAAG,CAACJ,GAAD,EAAMxD,QAAN,KACvBuD,YAAY,CAACC,GAAD,EAAMI,eAAN,EAAuB5D,QAAvB,CADb;;AAEAuD,MAAAA,YAAY,CAACvC,QAAD,EAAW4C,eAAX,EAA4B5D,QAA5B,CAAZ;AACA;AACD;;AA1WgE,CAAlE","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext: context,\n\t\t\t\tdependencies: dependencies,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.substr(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.substr(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.substr(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tresult[1].join(\"!\") +\n\t\t\t\t\t\t\t\t\t(result[1].length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource: result[0],\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tconst addDirectoryChecked = (directory, visited, callback) => {\n\t\t\tfs.realpath(directory, (err, realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addDirectory = (directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: resource,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\t\t\tsubResource.substr(resource.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request + resourceQuery + resourceFragment,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcategory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tif (typeof fs.realpath === \"function\") {\n\t\t\taddDirectoryChecked(resource, new Set(), callback);\n\t\t} else {\n\t\t\tconst addSubDirectory = (dir, callback) =>\n\t\t\t\taddDirectory(dir, addSubDirectory, callback);\n\t\t\taddDirectory(resource, addSubDirectory, callback);\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}